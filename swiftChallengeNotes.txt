113 SWIFT CHALLENGE (code for 113 days consecutively)

"Rise, let us be on our way"
‚ÄúLucious is safe‚Äù
"I can do all things through Christ, who strengthens me."
‚ÄúThe world is the way you see it‚Äù
"For what will it profit a man if he gains the whole world and forfeits his soul?"

The more you type, the more practice.
Big difference between knowing the path, and walking the path.

	ONLY BY ACTUALLY TYPING IN SWIFT CODE TO YOU BEGIN TO GRASP IT
	No rest for the wicked
	iOS apps don't grow on trees
	all about learning via repetition
	even when you're wrong, you're still learning


	https://www.hackingwithswift.com/100
	https://codewithchris.com/swift-tutorial-resources/
	https://www.raywenderlich.com/ios/learn

	-->	https://www.hackingwithswift.com/articles/113/nsattributedstring-by-example
		https://learngitbranching.js.org/


******
******
day48__Sun/7/21/_Day27: App Brewery (Dr. Angela)	
6am start time
645am end time
(45min net) COMPLETE‚úÖ

1110am 	sess2	(60min) 247 rev
4pm	sess3	(30min net) RayW
630pm	sess4	(60min net) RayW
******
******

Alerts work asynchronously (here, don't know in advance when alert will be done)
	let action = UIAlertAction(title/style/handlier: nil)
		XXX nil ====> {}
	let action = UIAlertAction(// handler {
	 action in
	self.startNewRound()
	})
		handler== tells alert what should happen when button pressed
		alert dismissed event
		closure executed when alter action tapped

Call back pattern

closure ~~ in-line method
	a method w/o a name
	when want to have block of code executed at some point in the future upon a certain event occuring
INSIDE closure == +self. ; outside == optional


Each screen in app managed by View Controller

The job of a View Controller:
	to managed a SINGLE screen in your app

Two parts of a View Controller:
	main.storyboard (design)
	ViewController.swift (code)

Want new View Controller?
	==> +Cocoa Touch class

Can make text VIEW UNEDITABLE via checkbox

Segue== transition from one screen to another
	CTR + DRAG__element ---> View Controller (present modally)

Dismiss method
	dismiss(animated: true, completion: nil)

Common beginner mistake:
	created View Controller in storyboard 
	created new swift file
	but failed to connect 
		@View Controller ===> Attributes Inspector (+'AboutViewController)
---
RayW
--
Can also CTR + DRAG from View Controller to view element

Local vs instance var
	local var ONLY exist for the duration of the method their in
	instance var exist for as long as the OBJECT THAT OWNS them exists

Local var easy to identify bc first time used in methods, preceded by let/var (creates new)
	//6 local var restricted to showAlert method; as soon as method done, var cease to exist
	&& each time method invoked, local var created anew w/old var discarded

Instance var defined outside any method ~~top of file
	declared in green
	can use inside any method w/o need to declare again
	
Use instance var if want to keep certain value around from one action event to next
Use local var for TEMPORARY storage

--
RayW
--
Expanding scope from local var in one method to more global access
From let ===> var (immutable to mutable)

self.itemArray.append(textField.text!)  +user enter data to 
self.tableView.reloadData()

Breakpoint??




******
******
day47__Sat/7/20/_Day26: App Brewery (Dr. Angela)	
630am start time
830am end time
(75min net) COMPLETE‚úÖ‚úÖ
******
******


===>attribute inspector box: "is initial VC" 
Note: 	Table VC not currently linked to .swift file
		===> inherit from UITableViewController
		===> change .swift file name && class declaration 
	recall: @identity inspector== specify class
		===> select prototype cell 
			===>reuse identifier ie 'TodoItemCell'

Want VC to have Nav bar: 
	Embed in Nav controller
		==>select VC===> EDITOR ==> "embed in Nav controller"
	+title
	+/- change color (bar tint)

Set items array
numberOfRowsInSection...	return itemArray.count
cellForRowAt
Table VC local vs global 
===> 1) dequeue cell (dequeueReusableCell)
===> set text label 

//MARK - TableView DataSource Methods
		numberOfRowsInSection...
			return itemArray.count
		cellForRowAt...
			dequeueReusableCell
			set text label
	vs
//MARK - TableView Delegate Methods
		didSelectRowAt...

@TodoItemCell ==> Accessory "checkmark"

+bar Button Item ===> System Item "Add" && change tint color?
	let alert = UIAlertController (title/message/prefStyle)
		vs
	let action = UIAlertAction
	alert.addAction
	present(alert/true/nil)

******
******
day46__F/7/19/_Day25: App Brewery (Dr. Angela)	
545am start time
715am end time
(90min) COMPLETE‚úÖ‚úÖ

1230pm sess2 	(60min net) 247 rev 
630pm sess3	(90min net) LB
******
******

Git && Version Control

	git init (initialize directory)
	ls -a	(see all hidden files)
	git status
		green? In staging area && being tracked
		red? In working directory && UNTRACKED
	git add fileName.txt (===> push to staging area && start tracking)
	git commit -m "add message in present tense" (convention)
		==> push to Local Repo
		to create new save point; be explicit && specific
	git checkout	to revert/rollback to previous commit 
	git diff chapter13.txt (see differences among files)
	git checkout chapter13.txt (roll back to last committed version of file)
Think Visual:	Working Directory vs Staging Areas vs Local Repo


Staging area == intermediate area; can pick && choose which files want to commit


Local vs remote repo	(.git vs GitHub)
Pushing an existing repo from command line:
	git remote add origin <http...>
		origin== name of remote repo (convention)
		master== name of default branch
	git push -u origin master (push from local ---> remote repo)
Local repo === git push ===> Remote repo


Git ignore
	touch .gitignore
	open .gitignore
		+file names on single line;  # == comment
	git rm --cached -r . (Remove everything) 
	*.txt (ignore all files that end in .txt)
===> Github ==> Swift ignore
			https://github.com/github/gitignore/blob/master/Swift.gitignore

git cloning
	git clone <httpURL>


BRANCHING && MERGING
What branch am I on?
	git branch (see all branches)
	git checkout new-branch-created
	git merge new-branch-created (ensure on MASTER)

	git fetch

	@VIM == :q! (Save && quit)

FORKING && PULL REQUESTS
Forking == making duplicate 

---
//MARK: -	for separating out code
//TODO: 	also appears in index outline
	P == properties
	M == methods
Any?	any object, legacy from objC
Convert, aka cast it, as known data type
	as! "Treat this data as .... a known dictionary"
Dictionary<String, String>
! Note use to unwrap optionals data
let message = Message()  (to create new message object)
...cellForRowAt		gets called for every cell
return messageArray.count	want to return count of the message array vs ~"3" (only 3)
SVProgressHUD (heads up display ~~ progress spinner)
	SVProgressHUD.show()
	SVProgressHUD.dismiss()

messageTableView.separatorStyle = .none


******
******
day45__Th/7/18/_Day24: App Brewery (Dr. Angela)	
530am start time
645am end time
(75min) COMPLETE‚úÖ‚úÖ

1215pm sess2 (60min) 247 rev
320pm sess3 (60min) 247 rev
6pm sess4 (30min net) RW
******
******

Algo == series of steps to solve a computational problem 
Stuck? ~write out steps in plain English 

IF statement
	if something is true {
		then do this
	} else if something else is true {
		then do that instead
	} else {
		do something when neither of the above are true
	}

var difference = currentValue - targetValue
if difference < 0 {
	difference = difference * -1 || difference *= -1 || difference = -difference 
let difference = abs(targetValue - currentValue)

var== changeable at any time
let== constant == once set, cannot change 

Rule of thumb: prefer let

Type inference

OPTION + CLICK

score += points --> score = score + points

RT CLICK element ---> New Referencing Outlet
		CTR + CLICK__drag (@ element VC for @IBOulet )


===
RW
====
--
? 20 : 120
NSAttributedString?
	Swift's strings are great for storing plain text, but as soon as you want formatting, images, or interactivity you need to reach for NSAttributedString - Foundation‚Äôs all-in-one string handling class. These are used in various places in iOS and macOS, but you're most likely to want to use them with UILabel and UITextView, both of which accept attributed strings directly.


----
	One can explicitly write @objc on any Swift declaration that can be expressed in Objective-C. As a convenience, Swift also infers @objc in a number of places to improve interoperability with Objective-C and eliminate boilerplate. This proposal scales back the inference of @objc to only those cases where the declaration must be available to Objective-C to maintain semantic coherence of the model, e.g., when overriding an @objc method or implementing a requirement of an @objc protocol. Other cases currently supported (e.g., a method declared in a subclass of NSObject) would no longer infer @objc, but one could continue to write it explicitly to produce Objective-C entry points.

Tween animations involve defining beginning && ending position of UI Image && specifying time to complete
Note:	@IBOutlet linked to contraints
		change height constraint programmatically to expand to larger field of UI Table View

1) detecting when user tapped text field
	+UITextFieldDelegate (setting up Chat VC as delegate)
	+explicitly set Chat VC as delegate (+self)

view.layoutIfNeeded()
UIView.animate(withDuration...
A trailing closure that includes animation instructions
Can register a custom Tag recognizer
	let tapGesture = UITapGestureRecognizer...
	
KEYWORD:	#selector (obj-C legacy)
			sometimes, need to call methods on objects we don't know about until app is running (at runtime)

func tableViewTapped...

Temporarily disabling text field && send button
[ ] == for collections (arrays & dictionaries)


	



******
******
day44__W/7/17/_Day23: App Brewery (Dr. Angela)	
545am start time
745am end time
(90min net) COMPLETE‚úÖ‚úÖ‚úÖ

1230mpm sess2 (20min)
430pm 	sess3 (20min net)
******
******

"Throws" == this fxn can Throw an error
We know certain fxn can fail ahead of time
When it's a method that can throw an error, have to call method in DO TRY CATCH block
	do { "this is the line of code that could give us trouble }
	+KEYWORD try before line code declaration

View Controllers are stacked ON TOP of each other && can be nested inside Navigation Controller
	gives Navigation Bar at top of View Controller(s)
Navigation Controller makes it easy to go forwards && backwards
	w/Nav Controller, get access to Back Button && Swipe feature

To embed View Controller(s) inside Navigation Controller
	====>EDITOR
		===>EMBED IN: NAVIGATION CONTROLLER
W/segues: show vs. present modally
		(part of Navigation path vs not-linked && will pop up)

THINK:	Pancake example

Recall:		remember to always import Framework(s) at top
		segue identifiers && navigation
		have to specify KEYWORD self before performSegue declaration if INSIDE A CLOSURE
		status bar vs Navigation Bar 
		Table View Controller drag vs Table View embed
		Table View embedded inside View Controller
		+adopt protocols
			UITableViewDelegate
			UITableViewDataSource

		

Auth.auth().signIn(with...) method via FB 

Table Views able to display number of cells one after another; can scroll vertically
	-lists that only have rows

1) adopt protocols
2) set Class as delegate
	messageTableView.delegate = self
	messageTableView.dataSource = self
3) +rq methods
	cellForRowAt	== what to display
		only loads up cells necessary to fill screen
		top cell offscreen becomes bottom cell offscreen
		reusing ~8/9 cells
Custom Cells created
	given identifier

	let cell = tableView.dequeueReusableCell(withIdentifier....
		indexPath refers to location w/initializing 
		indexPath == location identifier
	have to specify class as! Custom Cell ('an object of type CustomMessageCell')

to create new Custom cells
	===> +CocoaTouchClass
		==>subclass of UITable View
			MUST checkbox "Also create xib file" 
	what look like? (Xib == design file)
	what do? (Beh of cell == Swift file)

Must register xib file @viewDidLoad
	message.TableView.register...

1) cellForRowAt...
2) .dequeueReusableCell...
3) message.TableView.register...

+sections?
	numberOfSections	(return x)

44 height == standard for cells

configureTableView() 	initialize it


******
******
day43__Tu/7/16/_Day22: App Brewery (Dr. Angela)	
530am start time
713am end time
(90min net) COMPLETE‚úÖ‚úÖ‚úÖ

4pm sess2 (20min net)
******
******

Closures == anonymous fxn; self contained packets of fxn we can use
	input --> function ---> output
	anotherFxn (input) --> myFunction ---> yetAnotherFxn (output)

What if we wanted to pass in fxn as an input?
Can pass fxn as input parameter 
Can use fxn as return type 

	func nameOfFunc(input) --> Output { fxn }

To convert func to closure:
	XXX func declaration
	XXX func name
	move { to beginning of declaration
	replace { with in

	can remove 
		explicit data declarations 
		return keyword 

Closure have ability to provide anonymous parameter names
	$0 (first param)
	$1 (second param)

	if last parameter a closure, can remove closure name && just have trailing closure

Strike balance between simplicity && readability 

for loop vs map (map takes another fxn as input)

	map, reduce, filter

Closure Expression Syntax (general form):

	{ (parameters) -> return type in
		statements
	}

Recall MVC
	model (data)
	view (what user sees)
	controller (facilitates messages btw Model && View)

	the anatomy of an App (how an app works)
		Button && ViewController example
			User clicks button
				Button to ViewController ('hey got clicked, you need to update view')	
	operating system / View Controller / database ===> View Controller

Apps are event driven; writing code in anticipation of events
Events are messages that can be triggered

App lifecycle
	app launched
	app visible
	app recedes into background (held in memory)
	app recalled (resources reclaimed)

Swift coding ~~anticipation of messages

******
******
day42__M/7/15/_Day28: App Brewery (Dr. Angela)	
630am start time
8am end time
(90min) COMPLETE‚úÖ‚úÖ‚úÖ

130pm	sess2 (60min)
6pm	sess3 (60min)
******
******

Var has a lifetime (scope)
Where define var effects scope

3 levels of scope in Swift
	Global scope
		exist for duration of app && can be accessed from anywhere 
	Instance scope
		alive for as long as the object that owns them is alive
		think your current value
	Local scope
		only exist for the duration of method 

Instance variable == scope is the same as the object's instance that it belongs too
	use if want to keep around from one action to the next 

Recall
	Referencing Outlets via right-click
		New Referencing Outlet
			+ drag ---> View Controller
	\n	new line
	self.startNewRound()
		View Controller sending message to itself

	DRY	Don't. Repeat. Yourself.
	consider making new method for it
	generating random #
		randomValue = Int.random(in: 1...113)

Creating a method
	func yourFuncName() {
		//sexy code here
	}

Methods invoked by UIKit ( func viewDidLoad() )
Vs
Methods called by you

calling methods between the same object

Format to call method on object:
	receiver.methodName(parameters)
		receiver == object sending message to
			can leave out self in most cases
			ie "  alert.addAction(action)  "
		

Swift programming == a lot of calling methods on objects
===
RayW
===


One of the most fundamental component of modern iOS apps is the Table View. Table Views are used everywhere from the Mail app to the Messages app. It‚Äôs a crucial part of every iOS developer‚Äôs tool belt. In this tutorial we‚Äôll be getting to grips with Table Views, creating custom cells, and making our own cloud-based backend database.

Enter Firebase - cloud based infrastructure; acts a backend provider
Save && retrieve data from google services
Two core features:
	1) real-time database
		store our data on G servers
		have multiple devices retrieve data
	2) authentication 


Working w/FB Realtime Database, not Cloud Firestore


1) connect up app --> configure database
	FirebaseApp.configure()

When app launched, first file called, AppDelegate 
	let myDatabase = Database.database().reference()
		reference to brand new database w/I our database

Note comma on read/write rules == true, 

2) set up authentication

Recall: 
	pinch-to-zoom
	connecting segues
		Click <element> --> CTR + DRAG --> Destination release
	all segues need an identifier @Storyboard ( "goToChat" )
	CMD + ENTER (single editor screen)
	(completion?)	select PLACEHOLDER text ==> enter 
	if error != nil  ('there was an error')
	secure text entry field @main.storyboard --> password textfield box
	performSegue method == common to all View Controllers
	see in ? 
		inside closure (fxn w/I a fxn). A fxn w/no name
			when inside closures, have to specify where this method occurs
				(current class ---> self. BEFORE closure name declaration)

"Auth.auth().createUser..."	
	tap into FB authentication
	get authentication object
	use method to create new user

Callback triggered --> want to check if errors got sent back

----------------------------------------------------------

******
******
day41__Sun/7/14/_Day27: App Brewery (Dr. Angela)	
1145am start time
130pm end time
(90min) COMPLETE‚úÖ‚úÖ‚úÖ

410pm sess2 (30min) 
640pm sess3 
******
******


An app is made of objects 
	some provided by iOS; some written by you

Objects communicate by passing messages back & forth 
	UI BUTTON ===> "showAlert!" ===> View Controller

Apps are EVENT DRIVEN
	objects wait for events to occur, then process

App spends most time doing nothing == milliseconds

	1) User taps screen
		---> iOS detects touch, determines button tapped
	2) Touch event
		---> UIButton "you've been touched"
	3) showAlert
		---> View Controller
			button sends showAlert message to VC
	4) init, addAction
		---> UIAlertController
			View Controller creates UIAlertController object, send "add action"

EVERYTHING APP DOES TRIGGERED BY SOME EVENT

points vs pixels
	developers work w/points
	designers work w/pixels

What is an object?

Programmers likes to group related fxn into objects
	job: parse file
	job: authenticate user
	job: perform calculation


View Controller object (UIViewController)
Alert object (UIAlertController)
Button object (UIButton)
"Hit Me" object (string)

An object can have data && fxn; 
	HIT ME button:
		data == label color, position, width, height
		fxn == recognize user tap, highlight self, trigger action

Methods provide fxn
	method is simply a function that belongs to an object

Example: THROW PARTY

	func throwParty() {
	 	clean up
		put on kickass music
		// forgot to buy cookies
		steve.buyCookies(13)
		eat cookies
	}
					-->invited Steve object to party w/fxn:
	func buyCookies(howMany: Int) {
		bust out cash
		go to store
		buy cookies
		pay for cookies
	}


what are strings?
	imagine bunch of characters strung together on a wire
String interpolation (allow placeholder value that's replaced dynamically by code when app runs)	
	"Hello, \(gorgeousName)!"
		===>
		"Hello, Taylor Alison Swift!"
==> \ (   )

Variable value can vary (vs constant)
THINK:	children's blocks
	variables === blocks
	values == shapes
		value type determines what shape fits
"Put the right shape into the right container"

Syntax:
	var variableName: Type = InitialValue
	
	var taylorAge: Int = 29
	var gorgeousName: String = "Taylor Alison Swift"
	var currentValue: Int = 0

Type safety; have to be explicit 

Float --> Int?
	var x: Float = 3.13 
	var y: Int = Int(x)

One type to another == "casting"

Scope: how long variable lives
	local vs global


--
RAY
--
LearnEnough.com


	mkdr (make directory)
	touch newFile.txt
	open -a Xcode newFile.txt
	rm newFIle.txt
	rm * (wildcard; remove all of this type)
	rm -r newDirectory

scroll wheel == UIPicker == selecting multiple options
Count method 

recall		CMD + /
		Connection Inspector && setting up outlets
		pod init
		pod -a Xcode Podfile
		pod install
		if let (optional binding)
			bind result of " json["ask"].double to bitcoinResult var "
				if not nil, execute line of code

Date picker vs view picker
Picker sends message to View Controller (which currency was selected)

	The structure of UIKit apps is based on the Model-View-Controller (MVC) design pattern, wherein objects are divided by their purpose. 
	Model objects manage the app‚Äôs data and business logic. 
	View objects provide the visual representation of your data. 
	Controller objects act as a BRIDGE between your model and view objects, moving data between them at appropriate times.


******
******
day40__Sat/7/13/_Day26: App Brewery (Dr. Angela)	
7am start time
8am end time
(60min) COMPLETE‚úÖ‚úÖ
******
******

Delegate && protocols explained via 6 steps
	1) create Delegate protocol
		protocol ChangeCityDelegate { fxn }
	2) conform to protocol
		+adding to ViewController class declaration
	3) implement required method
	4) create delegate property (var delegate 
	5) set ourselves as delegate	(destinationVC.delegate = self)
	6) call Delegate method

delegate? ---> is delegate set or nil; if nil == line gets ignored

Receiver vs Protocol vs Sender

Delegate pattern always for reuse of components

CTR + CMD + SPACE == emoji inspector

Bash == Bourne Again Shell
why use command line? 
	greater control && efficiency
		mkdir
		ls 	ls -l (long) -a (include all files)
		ls (list)
		cd (change directory)
		cd ~ (home directory)
		cd / (root)
		cd ..
		CTR + ( A | E | U [clear line] )
		CTR + L | clear
		CTR + C (kill whatever running)

******
******
day39__F/7/12/_Day25: App Brewery (Dr. Angela)	
630am start time
8am end time
(60min net) COMPLETE‚úÖ‚úÖ

1130am session2 (30min)
930pm session3	(30min)
******
******

Alert in 4 steps
	1) create Alert Controller (UIAlertController)
		title
		message
		preferredStyle
	2) create alert action (UIAlertAction)
		title
		style
		handler
	3) add action (hook together)
	4) present view controller


Common beginner mistakes
Errors vs warnings (fatal vs informative)

---	
	TO DO:	repeat #165 && #167 == creating/using Segues && passing data

link View Controllers by segues 
func prepare for segue...
as!	create reference for 1st View Controller && cast as Second View Controller
Protocol == same hierarchical level as classes
Protocol == sets up rules of engagement
if going to be delegate, have to be able to handle data

Think:	
	1) create protocol
	2) conform to protocol
	3) implement required delegate method
	4) create delegate object variable

RECALL:
	click element
	CTR + DRAG to where want to link up segue to
	created new View Controller?
		==> identity inspector, assign Class to ___
	setting destination as! Second View Controller


******
******
day38__Th/7/11/_Day24: App Brewery (Dr. Angela)	
8am start time
10am end time
(90min net) COMPLETE‚úÖ‚úÖ‚úÖ

350pm session2 (40min)
830pm session3 (30min)
******
******


1) figure out what need to do
2) figure out how to do it

Programming To-do ==> list of all fxn
			---> break down into baby steps

	-text label description
	-score tabel
	-score label w/incremental score
	-round label  w/incremental rounds
	-hit me button
	-restart button
	-info button
	-slider from 1-100
	-pop up notification w/text 
	+generate random #
	+calculate score
	+reset game if tap button
	+app in landscape
	+make app pretty


1) hit me button
	connecting action to code

View Controller job: to manage a single screen in your app
	sometimes a portion of a screen
Two parts of View Controller
	Main.storyboard (Design)
	ViewController.swift (code == logic)

select Hit Me button --> HOLD CTR --> drag to View Controller --> click show alert 

	example: Recipe List
			recipe list ---> recipe details	
	2 screens == 2 View Controllers
	
			RecipeListViewController
			RecipeDetailViewController

Recall:		@IBAction func nameOfFunction() { }

---
NSObject?
It is one of the few root classes in Cocoa (the other immediately coming to mind is NSProxy). This predates Swift by a quarter of a century, mind you ;) It offers a number of useful features such as a default memory allocation scheme, a default comparison scheme  and the most important, being a root class it kickstarts the message passing machinery...
https://www.quora.com/What-is-NSObject-When-do-Swift-developers-need-to-use-NSObject

UInt?
didSet
$0, $1?
---
Segues allow us to link View Controllers && other UI elements w/I View Controller such as buttons
Segues help w/navigation
	Click segue ---> Note blue highlight

	to create new VC:
		 CMD + n ---> COCOA TOUCH CLASS file

Note:	SUBCLASS of UI View Controller (inherits from)
	Must go to IDENTITY INSPECTOR to link CLASS

To link up segue, have to give it an identifier
All View Controllers have method 	performSegue(withIdentifier___)

Note:	use of SELF
	use of OVERRIDE == override original method ____
	use of as! --> cast as ___ (second View Controller here)
	viewDidLoad == upon view loading

2 ways to set up segues
	1) from originating element
	2) from viewController

What user does on 1st screen ~~~> determines what happens on 2nd screen


Need to pass data between two View Controllers, how?
KEYWORD:	protocol (~~contract)

	segueDestination as! ChangeCityViewController --> "data type of segue set as__"

OPTIONAL CHAINING

******
******
day37__W/7/10/_Day23: App Brewery (Dr. Angela)	
545am start time
8am end time
	~20min break needed (too much mind Lv1)
(90min) COMPLETE‚úÖ‚úÖ‚úÖ

940pm session2
******
******


NSObject?

UInt?
didSet
$0, $1?
RECALL:		"rm testing.rtf" (USE CAUTION)
---

What's an API?
	Application Programming Interface== contract app must follow in order to get
	data from servers
	a contract prewritten && specified
	===>app makes REQUEST for API to website
	===>app passes parameters
	===>website returns RESPONSE that includes data

Trying to make request from app to servers ==> make http REQUEST
Response Handling == handling the Response of a Request
Method dictates what want to do		.get request here
Networking happens in asynchronous fashion

Make request to browsers ---> receive HTML/CSS data
Type of Request
	GET - fetching data
	POST - passing/adding data
	DELETE - delete some data

jSON	javascript Object Notation
If checked for error already, reasonably safe to force unwrap (!)

		jsoneditoronline.org

jSON== whole bunch of dictionaries nested into an array

We want to?
	pull out relevant data
	display to user via populating updated label/views w/updated data

See in? 
	===> inside a closure	
	===> always have to specify SELF before method calls (self.___)

Closure: fxn inside a fxn

	let tempResult = json["main"]["temp"] == "temp result now assigned this value of 281.13"


THINK:
	1) declare variables
	2) create new object(s)

RECALL:	
	CMD + /

Converting json data to .intValue / .stringValue

OPTIONAL BINDING == binding this tempResult value to value get back from json (safety: checking for errors)

Ideal place to call func?
	~~>after set properties/updated properties


******
******
day36__T/7/9/_Day22: App Brewery (Dr. Angela)	
545am start time
715am end time
(90min) COMPLETE‚úÖ‚úÖ‚úÖ
******
******


When using cocao pods, have to use WORKSPACE file (contains pods)
//MARK:  --> to separate code into discrete sections

Recall:		OPTION + hoverOver
		+import CoreLocation
		+ClLocationManagerDelegate
		+let locationManager = CLLocationManager()  [creating new object]
						*note: initialized w/no parameters

"WeatherViewController subclass of UIViewController that CONFORMS to RULES of CLLMDelegate"

locationManager.delegate = self 
	==> "refer to location manager 
	==> access delegate property via dot notation 
	==> set to self (WeatherViewController)

[ we set ourselves at the delegate == the current ViewController ] 

Asynchronous method == works in background (vs working in foreground)
Only interested in most accurate location ~last value collected
		
		---> via [locations.count - 1]
		to convert to String ---> String(input)

If want to use Location Manager code, have to set delegate, class that will handle data
	View Controller == "I will be the delegate"

Dictionary holds data via key-value pair (order not important like arrays)
Dictionary retrieves data via key in key-value pair

Recall:		arrays && index positioning

THINK:		CINEMA CLOAKROOM EXAMPLE
			name : coat vs "1-2-3-4-5-6...."

	-->	let latitude = params["lat"]
		let longitude = params["lon"]

Arrays && dictionary == collection types == help organize data

What are APIs?
******
******
day35__M/7/8/_Day21: App Brewery (Dr. Angela)	
545am start time
715am end time
(90min) COMPLETE‚úÖ‚úÖ‚úÖ

230pm session2
(60min) COMPELTE‚úÖ‚úÖ
******
******


We‚Äôre going to introduce you to the wonderful world of Cocoapods and open source libraries.
Additionally, we‚Äôll learn how to call Application Programming Interfaces (APIs) to grab data from websites.

Cocoapods == dependency manager for Swift; tons of libraries (collections of code)

VERY IMPORTANT HOW YOU EDIT PODFILE

POD INSTALL FLOW

	pod init
	open -a Xcode Podfile
		delete HASHTAGS # 
		+ rq pods

	pod 'SwiftyJSON'
	pod 'Alamofire'
	pod 'SVProgressHUD'
	pod --version
	pod install
	(pod update)


--
recall: 	viewDidLoad
		we know we inherit viewDidLoad() from UIViewController, but we want to 
		OVERRIDE it's fxn, and + our own fxn
		use of dot notation to access fxn


Trying to OVERRIDE (add on) to existing fxn?
KEYWORD:	super --> refers to Super class inherited from
		ie super class of SelfDrivingCar == Car

1st== 	carry out fxn from Car()
		" super.drive() " 
2nd==	add on new fxn for SelfDrivingCar


1) INHERIT fxn from superclass
2) OVERRIDE fxn to add on new fxn

"" vs NO DATA (nil)
nil/null pointer error
? == "could contain a nil value" (done at creation stage== declaring var/constants)
? == "could have a value, or not"
! == to FORCE UNWRAP OPTIONAL for use
! == serves as MANUAL OVERRIDE ("definitely does not have a value")

OPTIONAL BINDING
	check to see if declared variable/constant definitely has a value
	SYNTAX	if let
		let to create new constant
		if to check 
		print between { } ONLY gets executed when declared variable IS NOT NIL 
		(has a value)

Using optional binding, don't have to force unwrap (dangerous)
IF LET safer

RECALL		variables as boxes
	only when unwrap box: value or not?
	? == could contain value or not
		ie var destination: String?	(String optional data type)
	! == to FORCE UNWRAP
		ie var destination: String! 	["I know has value & not nil"]
	
OPTIONAL BINDING== SHAKE BOX FIRST (check to see IF has value)
	String vs Optional String data type
	data types have counterpart OPTIONAL (?) data type
	! == force unwrapping (ie converts from String? --> String)

IF LET
	safer way
	ONLY WHEN NOT NIL, execute declared code w/I braces { }

		if let userSetDestination = destination {
			print("driving towards " + userSetDestination)
		}
	===> "if let newConstantDeclared equal to value of Optional
		if optional has value, execute print statement
		if destination == NIL == CHECK NOT PASSED == print not executed		 
	
******
******
day34__Sun/7/7/_Day20: App Brewery (Dr. Angela)	
640am start time
8am end time
(60min) COMPLETE‚úÖ‚úÖ

8pm session2
(30min) COMPLETE‚úÖ
******
******

Recall:	Animal Kingdom INHERITANCE example

	class Mammals: Animals {
	var hasHair: True
}
	class Birds: Animals {
	func canFly() {}
}
	class Humans: Mammals {
	func useComputer() {}
}

SUBCLASSES INHERIT FROM SUPERCLASS && INHERIT IT'S PROPERTIES && FXN

Recall:
	open && close parenthesis () when creating new object instances
	ONLY BY ACTUALLY TYPING IN SWIFT CODE TO YOU BEGIN TO GRASP IT

KEYWORD: 
	override == in order to OVERRIDE existing fxn from inherited class

SWIFT CONVENTION: declare override keyword BEFORE func
	ie 	override func viewDidLoad() { }
		super.breathe() == do all fxn of breath(), but also + new fxn
RECALL:
	class ViewController: UIViewController {}
		ViewController INHERITS UIViewController fxn


	override func viewDidLoad() {
		super.viewDidLoad()

		updateUI()
	}
		===>	super.viewDidLoad() == refers to SUPER class of viewDidLoad == UIViewController; load up viewDidLoad, but then add new fxn [ updateUI() ]

--
Enums allow for custom data types instead of using something ambiguous like, "1, 2, 3"
Note open && close parenthesis () when creating new Class
What are the various properties of our newly created object?

What if we want a SPECIAL car beyond the STANDARD setting?
Option 1: custom initializer
init: "a set of statements that prepares AN INSTANCE of a class, structure, enumeration for use"
What happens when init METHOD triggered?
Note previous Car Class declaration had no parameter input

	Programming: predicting your outcome, comparing expectations, debugging

	INITIALIZERS ALLOW YOU TO OVERRIDE DEFAULT SET PROPERTIES
init METHOD is an EVENT (point in program where object gets created, "initialized")

Designated vs convenience initializer 
	Designated init (default one) has compulsory parameters that require an input (cannot ignore)
	Convenience init == an optional initializer 
	"self. " ---> refers to own class
Designated init w/ DEFAULT setting vs Convenience init w/optional Custom setting
Convenience init == an add-on

Note:	position of func when declaring it
	dot notation allows access of Variable properties && Methods
	V == Variable, M == Method
	COMMAND + S whenever possible in Swift

If func declared w/I class == METHOD
METHOD ALWAYS ASSOCIATED W/AN OBJECT

Note:	you specify inheritance w/I Class declaration via COLON (:)


******
******
day33__Sat/7/6/_Day19: App Brewery (Dr. Angela)	
645am start time
830am end time
(90min) COMPLETEE‚úÖ‚úÖ‚úÖ

345pm session2
(30min) COMPLETE‚úÖ
******
******

Classes == blueprints for creating objects w/certain properties
KEYWORDS always in pink
When creating new classes, new swift file required. Ensure TARGETS checkbox accurate
Class CONVENTION == first letter Capitalized
First thing's first: add the properties

ENUMs are about creating CUSTOM DATA TYPES.
SWIFT CONVENTION:

	enum(s) declared at top 
	enums Capitalized via camelcase ie enum CarType
	cases w/I enums NOT CAPITALIZED. But first letter property is.
	enum structure:
		enum CarType {
			case One
			case Two
			case Three
		}


dot notation to access Case types
Enumerations && setting buttons titles(!) 

Buttons use the Target-Action design pattern to notify your app when the user taps the button. Rather than handle touch events directly, you assign action methods to the button and designate which events trigger calls to your methods. At runtime, the button handles all incoming touch events and calls your methods in response.

---
Note use of OPTION + DRAG (to copy UI elements)
Stacking UI elements together
Equal distribution
Points of spacing between UI elements
Horizontal vs vertical stacking
Clearing constrains; re-adding
Use of Equal Widths
Use of multipliers with stack views (ie 1:2.1)
Achieving padding by modifying stack view, "align trailing to"


******
******
day32__F/7/5/_Day18: App Brewery (Dr. Angela)	
730am start time
900am end time
(90min) COMPLETE‚úÖ‚úÖ‚úÖ
******
******

How to make designs look great across all devices, and/or orientation?
1) programmatically 
2) AUTO LAYOUT via setting constraints - rules for program to abide by 


viewDidLoad == cycle of app where view first gets displayed for user
UIView == class (blueprint)
CG == CoreGraphics
by default, UIViews are transparent; need to set background color property to make visual for user
(x: 0, y: 0) == refers to TOP LEFT-HAND CORNER position
Need to determine height/width of screen when positioning objects
self.view.frame.width/2 == refers to current view controller
The larger the screen, the larger the screen w/H

Constraints allow us to set rules as to how we want our views to be displayed. Because mobile screens have different resolutions and sizes, we need these rules to tell the iPhone/iPad how it should layout the display. These rules allow our UI elements to be resized and positioned so that no matter which screen they are displayed on, they always look as the designer intended.

FLOW
	Uncheck constraints to margin button
Order matters
Instead of constraining to margins (default setting), constrain to edge of screen
Clearing constraints on current view element view entire view (~RESET BUTTON)
Pinning vs alignment method (and/or)
Introducing CONTAINERS to hold views
Sibling vs child relationships
nesting
"Inside a folder vs creating a folder"
4 zeroes contraints
"Always position this way inside the container"
"Pin this edge, pin this edge"
0 refers to closest element neighbor
Create containers that will always evenly distribute
Background color to default == colorless


******
******


One of the most important steps to take in order to make the jump from
learner coder to a fully fledged programmer is understanding how to get
help. Everyone needs help. Everyone, including those so-called ‚ÄúGod Level
Programmers‚Äù

But what you do with the help will determine how fast you progress as a
coder. On a site like StackOverflow, it can be very tempting to just copy and
paste the code that someone has provided. 

exercise didn‚Äôt teach you anything other than code reliance. 

same code snippet that someone provided may not work anymore. Then
what do you do? You‚Äôre stuck

 there‚Äôs a rule in programming that says ‚Äúnever copypaste code
that you don‚Äôt understand‚Äù. So what should you do when you‚Äôre confronted
with a block of code that solves your problem but you have no clue how it
works? Break it down.

Step 1 - Copy and paste the code
Step 2 - Make sure that your program or application is functioning as
expected.
Step 3 - Delete the copy and pasted block of code LINE BY LINE.
Step 4 - Each time you delete a line, check to see what‚Äôs been broken. Does
the app still run? What are the error codes? What has deleting that line of
code done to your program?
 most important task as a programmer is to always test your
assumptions against the outcome. For the most enjoyable feeling as a
programmer is for the real world to validate your assumptions. 
‚ÄúYou were right‚Äù.
It‚Äôs like that, but better.
Step 6 - Swap some of the lines around. Can the same functionality be
achieved with a different order of lines? Why were they written in the order
they were written in?
By breaking the solution code, line-by-line, you‚Äôll learn and understand what
each line does and why it‚Äôs been written. This is a far better way to use code
from other people than just pasting it in and hoping for the best. 
Think about the structure of their program. Take a look at all the classes,
the constants, the interplay. Make some modifications to the code. Does it
still work or have you broken it? Why did you break it? Is there a link that
you didn‚Äôt identify? Ask yourself a bunch of questions, learn through the
SOCRATIC METHOD. Tear down the project and understand how it was built.

When you start getting really good at this, the next thing you can try is
reverse engineering. Find a small project on GitHub made by a reputable
programmer, download the app. Run it and see all of its functionality. Play
around with it.
Then build it from scratch and once you‚Äôre done, compare your code to their
code. Are there efficiency gains that you could have made? Are there
solutions to things you couldn‚Äôt figure out? Now you‚Äôre really getting into the
big leagues.



******
******
day31__Th/7/4/_Day17: App Brewery (Dr. Angela)	
630am start time
800am end time
(90min) COMPLETE‚úÖ‚úÖ‚úÖ
******
******

RECALL If-else clauses work like as such:
	if (condition 1) {
		statement1;
	} else if (condition2) {
		statement2;
	} else {
		statement3;
}


RECALL use of pseudo code
	"if topButton was pressed {
		change the storyTextView to story 3
		change the topButtonTitle to answer3a
		change the bottomButtonTitle to answer3b
	} "	


First: 	what going to make? 
	what UI elements are required?
	IF sender.tag == 1 vs sender.tag == 2 THEN
		want to CHECK IF sender.tag is 1 vs 2
		everything given sender.tag = 0 by default

dot notation to access properties

Recall 
	use of ELSE IF
	use of || or operator
	use of .isHidden = true vs false for button property

THINK:	a number to define where user is? (Track them/progress)
	where is user?
	what button did user press?
	reassigning of variables


COMMAND A ---> OPTION + CONTROL + I == align text

In VIM
	In the text editor, press computer's i key to edit the file (place in INSERT MODE)
	after editing, press ESC (will put vim in COMMAND MODE)
	to save, type :w
	to exit, type :q
	to save && exit, type	:wq
	to discard changes, type :q!


******
******
day30__W/7/3/_Day16: App Brewery (Dr. Angela)    
1pm start time
COMPLETE
******
******

The goal of this tutorial is to get you comfortable with thinking about the state of your app and updating the Views accordingly. In addition, you will be using logic to control the flow of the program. This is a challenge where you‚Äôll solidify your understanding of IF-ELSE statements and comparison operators.

app will tell a story depending on what the user chooses and can be fleshed out and modified to provide an engaging story-telling experience

think:
    //our strings/constants/var
    //UI Elements linked to storyboard
    //initializing variables
    //User presses button(s)    (triggering IBAction)
        The ‚Äúsender‚Äù in the brackets refers to the button that triggered the IBAction
        need the tag property to distinguish WHO TRIGGERED the IBAction. 
        can do this by checking sender.tag
            if sender.tag == 1...
            if sender.tag == 2...

creating empty text file in shell (bash!)
	touch foo.txt	==	>>foo.txt
	touch ~/Downloads/newTay.txt

Recall
	echo "Hello Taylor Alison Swift" >13fortaylor.txt
	echo "Hello Taylor" > ~/Downloads/somethingElse.txt

short answer:
	terminal = tty = text input/output environment
	console = physical terminal
	shell = command line interpreter
   

Buttons have a state because they can be pressed, highlighted, or disabled. Each may have different appearances or titles. Apple says we should set the value for the normal state at minimum

To figure out which route the user should take, got to use the TAG associated w/buttons.

Recall logic operators:
	== to test EQUALITY.
	E.g. (someValue == 5) tests ‚ÄúIs someValue equal to five?"

&& single = sign used for ASSIGNMENT 
	i.e. something = 3. 


Keeping track of state

&& --> logical AND operator
	(storyIndex > 3 && storyIndex < 5) tests ‚ÄúIs storyIndex greater than three AND is 	storyIndex smaller than five?‚Äù
|| --> logical OR operator. 
	(storyIndex == 3 || storyIndex == 4) tests ‚ÄúIs storyIndex equal to three OR is 		storyIndex equal to four?‚Äù

When the user gets to the stories without answers, you can hide the buttons using the syntax:  buttonName.isHidden = true


On macOS systems, the configuration file is found at ‚Äú/private/etc/ssh/ssh_config,‚Äù which is symlinked to ‚Äú/etc/ssh/ssh_config‚Äù for compatibility.

A second, user-specific ssh_config is found at ‚Äú~/.ssh/ssh_config.‚Äù If it exists, this file supersedes the system-wide configuration file. This file sets user-specific options without changing the system‚Äôs configuration.

touch foo.txt


******
******
day29_tu/7/2_day15: App Brewery (Dr. Angela)
10pm start time
COMPLETE
******
******

Recall use of +=
		score += 1 --> score = score + 1

Where does it make sense for this to happen?
Escaping a string
Declaring a function vs calling function
Does code work as expected?
Variables as state trackers	

How can we give the user feedback?
No console for user
Print statements == only developer sees
Power of 3rd party libraries 
	"HUD == Heads Up Display" visual (objective-C code)
	note bridging header creates
3 steps to use code:
	1) git clone repo
	2) drag/drop 3 files into Supporting Files folder
	3) "#import ProgressHUD.h" ---> BRIDGING HEADER file
ProgressHUD dot notation
NO POINT IN REINVENTING THE WHEEL

REVISITING COMMAND LINE
	-repo
	-commit
	-branch
	-merge
	-fork
	-pull request

commands:
	cd	pwd	ls	cd... 	clear	open . 	ls -all
	cd + drag folder
	power of tab && autocomplete


Starting out, maybe easier to create folder on GITHUB --> clone
	vs using git init


	git clone
	git status
	git commit -a
	git commit -a -m "Creating new file"

Get git error? "You can suppress this message by..."

	git config --global user.name "Your Name"
	git config --global user.email 
	git config --list
	git log
	git log -2

VIM!	(terminal based)

	" : q "	 IF GET STUCK IN VIM

	git push
	git pull
	git remote
	git remote -v
		"remote" == duplicate instance of your repo that lives on github.com

	
	git push origin 
			ORIGIN JUST THE DEFAULT NAME git use when cloning repo

	git push origin master
	
	git init --> turn it into an empty git repo
	
Idea of staging

3 steps
	1) save file
	2) add it
	3) commit it

	git commit -a 	(add it && commit it)
	git commit filename.txt	vs	git commit -a (all files)

IF STARTING ON GITHUB: remote already associated
vs.
IF STARTING LOCALLY, HAVE TO CREATE REMOTE

	git remote
	git remote -v
	git remote add origin ("add a remote named origin" == convention)
	git remote add origin <URL>
	git pull origin master

Generate new SSH

	hidden .ssh folder



day28__M/7/1/_Day14: App Brewery (Dr. Angela)	
ON #106‚Ä¶.

	 ‚úÖ‚úÖ1pm
	session2 
When you see real programmers working. They tend to look like this:
Yep, that‚Äôs right. No typing. Just staring. A lot of staring. For there‚Äôs a bug, there‚Äôs always a bug. Other people might not understand, but in these situations, it‚Äôs almost always worth stepping away from your code and giving it some time and distance. Do you have a bug in your code that you can‚Äôt work out? Sleep on it, play foosball, go for a walk. In 9 out of 10 cases, the solution will become apparent. In the remaining 1 out of 10 cases, you‚Äôre just screwed. So remember, the easiest code to get rid of is the code that was never written.

Assigning vs eauality	( =  vs. == )
Utility of sender tags
Code looks inside braces, ‚Äúwhat should I do?‚Äù
Creating vs calling a method
Knowlege layers; honesty; progression; forward, review, back, pause, repeat, 

Var created on top 
Using variable to keep track of STATE	(ie state of which Q user is on)
In programming, don‚Äôt get to blame anyone else but yourself

Note use of lldb in debug console; and print X var
Can leverage print to guide your debugging
There will be flaws in your logic; bugs in your code

modal alerts
Action sheets for for bottom
IF see in, think SELF
	


day27__Sun/6/30/_Day13: App Brewery (Dr. Angela)	
	‚úÖ845pm 
	QUIZ app again

	info.plist file == think KEY : PAIR	XML 
		short for property list (stores config info at runtime 
		similar to dictionary, KEY is the property name && VALUE is the 			configuration
	COMMAND + .  == STOP SIM
	importing libraries == Swiss army knives
	MODEL folder for storing data 
	when declaring classes ==> CAPITAL first letter
	properties are variables associated w/a class
	a METHOD is a FXN associated w/a CLASS
	when you initialize, you give a starting value. Possible?
	init()  ‚Äî>. A METHOD. The Init Method determines what happens when new OBJECTS are created from this class
	classes == blueprint

	MVC model == think Restaurant analogy
	class: blueprint == instructions 
	OBJECTS ARE CREATED FROM CLASSES
	objects have properties (constant/var), Events (fxn) && Actions 
	Events == how to respond to things
	init() used to define an event (what happens when new Q are created)

	
	init() empty
	
	CONTROLLER HANDLES COMMUNICATION BETWEEN MODEL && VIEW
	MODEL: manger that manages data
	restaurant analogy
	CONTROLLER controls what get displayed on screen
	think FLOW of obj
	why implement MVC? 1) provide structure 2) collaboration 3) CODE REUSE 4) allow multi-tasking


	

day26__Sat/6/29/_Day12: App Brewery (Dr. Angela)	
	‚úÖ10am= start 
	520pm session 2

	learnxinyminutes.com
	https://www.youtube.com/watch?v=0fKg7e37bQE
	(GitHub)
	gitclone <URL>
`	git status
	git add  <fileName>
	git add . 		(everything in directory)
	git add -A	‚Äú
	git commit (locking it ) -m (giving message, but on my machine)
	git push	(send to the cloud)
	git pull
	git	(all commands)

Actual flow:
	git pull
		my changes
			git add -A 	(All)
				git commit -m
					git push
	esc 
		:wq

Repository | repo
Start gitHub ‚Äî> command line
the. commit. hash. üî•üî•üî•üî•

Branching
oull request		up to reviewer to accept vs reject
Merge 
Fork
	
	cd	pwd		ls		clear		open . 
	up/down arrows
	cd SPACE (drag folder)
	ls -all

	




day24__F/6/28/_Day12: App Brewery (Dr. Angela)	
	‚úÖ5am= start 
	11am session 2


day23__TH6/27/_Day11: App Brewery (Dr. Angela)	
	‚úÖ7p=m start 
day22__W/6/26/_Day10: App Brewery (Dr. Angela)	
	‚úÖ530am start 
	7:30pm session 2

	property list == .plist	file stores config info at runtime
	info stored in format == key-value pair
	(similar to dictionary, key == property name, value== config)

	MVC== model, view, controller
	model == where data model stored
	import libraries == like Swiss army knives
	when declaring classes,  first letter always CAPITAL
	properties are variables associated w/a class
	method is a fxn associated w/a class
	method vs fxn
	init() { } ‚Äî> when you initialize, you give starting values
	classes == blueprints (from which objects are created from)
	init() method

	review notes/ + from last 2 vids

Jeff Goodell:¬†Would you explain, in simple terms, exactly what object-oriented software is?
Steve Jobs:¬†Objects are like people. They‚Äôre living, breathing things that have knowledge inside them about how to do things and have memory inside them so they can remember things. And rather than interacting with them at a very low level, you interact with them at a very high level of abstraction, like we‚Äôre doing right here.
Here‚Äôs an example: If I‚Äôm your laundry object, you can give me your dirty clothes and send me a message that says, ‚ÄúCan you get my clothes laundered, please.‚Äù I happen to know where the best laundry place in San Francisco is. And I speak English, and I have dollars in my pockets. So I go out and hail a taxicab and tell the driver to take me to this place in San Francisco. I go get your clothes laundered, I jump back in the cab, I get back here. I give you your clean clothes and say, ‚ÄúHere are your clean clothes.‚Äù
You have no idea how I did that. You have no knowledge of the laundry place. Maybe you speak French, and you can‚Äôt even hail a taxi. You can‚Äôt pay for one, you don‚Äôt have dollars in your pocket. Yet, I knew how to do all of that. And you didn‚Äôt have to know any of it. All that complexity was hidden inside of me, and we were able to interact at a very high level of abstraction. That‚Äôs what objects are. They encapsulate complexity, and the interfaces to that complexity are high level.



94501

(REV HERE==>)	day22__Tu/6/25/_Day9: App Brewery (Dr. Angela)	
	‚úÖ‚úÖ630am start (45min)
	‚úÖ713pm session2

	Import AVFoundation ‚Äî> declare class ‚Äî> define var

	DO CATCH TRY == ERROR CATCHING

	do {
}
	catch {
}
	executing this method can THROW an ERROR


osstatus.com  		(ERROR CODES)

`	‚Äú ! ‚Äú == serves as MANUAL override
Ie	
	instead of do {} && catch { } blocks
		‚Äî> try! 

	define FUNC after IB ACTIONS‚Ä¶
	
	sender.tag utility 

	arrays start counting from 0

	tags are given by default
	
	‚Äúsender.tag - 1‚Äù
	
	think: problem with hard coded data
	
	scope

	local vs global variables == ACCESSIBILITY 

	setting empty variables s/a : String = ‚Äú‚Äù (empty string!

/-/-/
	scope is about visibility of var
	LOCAL VAR only visible w/I curly braces
	THINK GRADEN APPLE TREE EXAMPLE
		only you can access vs everyone can access
		placement w/I wall vs communal

	func w/INPUTS (parameters)

	GLOBAL > LOCAL VAR
		whenever possible, try to avoid using global variables. 
		whenever possible, keep the apple tree in your own garden

	


day21__M/6/24/_Day8: App Brewery (Dr. Angela)	
	‚úÖ1030am start
	‚úÖ1413pm session2

	sum += number is the equivalent of
		sum = sum + number

	for constant in arrayOfNumbers THINK single digit of XYZ 
Recall:
	for number in 1...10 {	(inclusive of 10)
	vs
	for number in 1..<10 {	(DOES NOT INCLUE 10)

	use of % MODULO REMAINDER

	ie number % 2 == 0 	== ‚Äúdivides cleanly into 2, thus must be even‚Äù
	3 % 2 ‚Äî> 1
	4 % 2 ‚Äî> 0
	5 % 2 ‚Äî> 1
	13 %2 ‚Äî> 1

	keywords: 	FOR		IN		WHERE

	\n (‚Äúbackslash n‚Äù)	==> CREATES NEW LINE
	+ before == new line
	+ end of line == big empty space

	for number in (1‚Ä¶99).reversed() {‚Ä®}
	(until X :  Int )

	if not using keyword in FOR IN loops, replace w/ underscore ‚Äú_ ‚Äú
Ie:
	for iteration in 0‚Ä¶n {} ==> for _ in 0‚Ä¶n {}

	do catch blocks (for catching errors: try this‚Ä¶if error, print out this statement
	hold down OPTION key / command key too

projectEuler.net
stackoverflow.com
Forums.developer.apple.com
developer.apple.com/reference


day20__Sun/6/23/_Day7: App Brewery (Dr. Angela)	
	‚úÖ715am start 

IF ELSE: think. forest:
	walking. 
	On left side IF ARROW
	on right side ELSE ARROW. 
	Straight down center (and at slight down angle) ELSE IF ARROW

On fxn:
	think: INPUT_OUTPUT_INSTRUCTION (IOI)

And remember, call, the, function. 
Swift not read right to left like English.


day19__S/6/22/_Day6: App Brewery (Dr. Angela)	
	‚úÖ630am start 

Recall COMMAND + / 


day18__F/6/21__Day5: App Brewery (Dr. Angela)
	‚úÖ613am start 

GOOGLE ‚Äúxyz Apple Documentation‚Äù

This is the most important part of learning to code. It‚Äôs much like cooking. You can learn to make cakes with recipes in the beginning, but you only become a chef when you start making your own creations without a recipe. 
	Right now, don‚Äôt aim for 3 Michelin stars. Aim for edible.

day17__Th/6/20__Day4: App Brewery (Angela)
	‚úÖ630am start session1
Recall:
	-var & constants CONTAINERS for data
	-var == data can be swapped in/out of container
	-let (constant) == data CANNOT be changed

Think of a box. 
	Constant == 1 data item == close box. 
	Variable == OPEN box == variable items



day16__W/6/19__Day3: App Brewery (Angela)

	‚úÖ7am start session1
	2pm session2 (30min)

day15__Tu/6/18__Day2: App Brewery (Angela)
‚úÖ745am start session1
	https://www.appbrewery.co/
	flatuicolors.com
	appicon.co
	canva.com


day14__M/6/17__Day1: App Brewery (Angela)

	Learning to code is a bit like going to the gym. Even if you max out and spent a whole weekend at the gym, you will not see a visible difference in your body. The more regularly you learn to code, the more likely it is that you‚Äôll start seeing your ripped coding muscles. 
	left me with only 9 hours remaining in my day. 
	Theoretically, 2 hours could be allocated to coding practice and 7 hours on sleep. But there is nothing more difficult than trying to convince your work-saturated brain to sit down and learn when you could be watching Game of Thrones with a tub of ice-cream.
	First, you must understand that task-switching is very difficult. It requires a lot of motivation. If as soon as you get home, you slump on the sofa and switch on the TV, you‚Äôve already lost that evening. This is because the amount of motivation required to task-switch and do something not driven by evolution like eating or sleeping is a Herculean task.


day13__Sun/6/16__Day#12: OPTIONALS &&

still owe: https://www.hackingwithswift.com/sixty/10/8/optional-try
7/11 == 64%‚Ä®
That runs a throwing function, using¬†do,¬†try, and¬†catch¬†to handle errors gracefully.
There are two alternatives to¬†try, both of which will make more sense now that you understand optionals and force unwrapping.
The first is¬†try?, and changes throwing functions into functions that return an optional. If the function throws an error you‚Äôll be sent¬†nil¬†as the result, otherwise you‚Äôll get the return value wrapped as an optional.

When talking about force unwrapping, I used this code:
let str = "5"
let num = Int(str)
That converts a string to an integer, but because you might try to pass any string there what you actually get back is an¬†optional¬†integer.
This is a¬†failable initializer: an initializer that might work or might not. You can write these in your own structs and classes by using¬†init?()¬†rather than¬†init(), and return¬†nil¬†if something goes wrong. The return value will then be an optional of your type, for you to unwrap however you want.
As an example, we could code a¬†Person¬†struct that must be created using a nine-letter ID string. If anything other than a nine-letter string is used we‚Äôll return¬†nil, otherwise we‚Äôll continue as normal.
Here‚Äôs that in Swift:

You‚Äôve made it to the end of the tenth part of this series, so let‚Äôs summarize:
1. Optionals let us represent the absence of a value in a clear and unambiguous way.
2. Swift won‚Äôt let us use optionals without unwrapping them, either using¬†if let¬†or using¬†guard let.
3. You can force unwrap optionals with an exclamation mark, but if you try to force unwrap¬†nil¬†your code will crash.
4. Implicitly unwrapped optionals don‚Äôt have the safety checks of regular optionals.
5. You can use nil coalescing to unwrap an optional and provide a default value if there was nothing inside.
6. Optional chaining lets us write code to manipulate an optional, but if the optional turns out to be empty the code is ignored.
7. You can use¬†try?¬†to convert a throwing function into an optional return value, or¬†try!¬†to crash if an error is thrown.
8. If you need your initializer to fail when it‚Äôs given bad input, use¬†init?()¬†to make a failable initializer.
9. You can use typecasting to convert one type of object to another.

Recall: guard must be followed by else

day12__Sat/6/15__Day#11: OPTIONALS &&

Null references ‚Äì¬†literally when a variable has no value ‚Äì¬†were invented by Tony Hoare way back in 1965. When asked about it in retrospect, he said ‚ÄúI call it my billion-dollar mistake‚Äù because they lead to so many problems.

This is the last day that you‚Äôll be learning the fundamentals of Swift, and it‚Äôs devoted exclusively to Swift‚Äôs solution to null references, known as¬†optionals. These are a really important language feature, but they can hurt your brain a little ‚Äì¬†don‚Äôt feel bad if you need to repeat some videos a few times.

We‚Äôve used types such as¬†Int¬†to hold values like 5. But if you wanted to store an¬†age¬†property for users, what would you do if you didn‚Äôt know someone‚Äôs age?

You might say ‚Äúwell, I‚Äôll store 0‚Äù, but then you would get confused between new-born babies and people whose age you don‚Äôt know. You could use a special number such as 1000 or -1 to represent ‚Äúunknown‚Äù, both of which are impossible ages, but then would you really remember that number in all the places it‚Äôs used?

Swift‚Äôs solution is called¬†optionals, and you can make optionals out of any type. An optional integer might have a number like 0 or 40, but it might have no value at all ‚Äì¬†it might literally be missing, which is¬†nil¬†in Swift.
To make a type optional, add a question mark after it.¬†

Optional strings might contain a string like ‚ÄúHello‚Äù or they might be nil¬†‚Äì nothing at all.

What happens if we use¬†name.count? A real string has a¬†count¬†property that stores how many letters it has, but this is¬†nil¬†‚Äì¬†it‚Äôs empty memory, not a string, so it doesn‚Äôt have a¬†count.

Because of this, trying to read¬†name.count¬†is unsafe and Swift won‚Äôt allow it. Instead, we must look inside the optional and see what‚Äôs there¬†‚Äì a process known as¬†unwrapping.

A common way of unwrapping optionals is with¬†if let¬†syntax, which unwraps with a condition. If there was a value inside the optional then you can use it, but if there wasn‚Äôt the condition fails.

If¬†name¬†holds a string, it will be put inside¬†unwrapped¬†as a regular¬†String¬†and we can read its¬†countproperty inside the condition. Alternatively, if¬†name¬†is empty, the¬†else¬†code will be run.

An alternative to¬†if let¬†is¬†guard let, which also unwraps optionals.¬†guard let¬†will unwrap an optional for you, but if it finds¬†nil¬†inside it expects you to exit the function, loop, or condition you used it in.

However, the major difference between¬†if let¬†and¬†guard let¬†is that your unwrapped optional remains usable after the¬†guard¬†code.

Let‚Äôs try it out with a¬†greet()¬†function. This will accept an optional string as its only parameter and try to unwrap it, but if there‚Äôs nothing inside it will print a message and exit. Because optionals unwrapped using¬†guard let¬†stay around after the¬†guard¬†finishes, we can print the unwrapped string at the end of the function:

Using¬†guard let¬†lets you deal with problems at the start of your functions, then exit immediately. This means the rest of your function is the happy path ‚Äì the path your code takes if everything is correct.

Optionals represent data that may or may not be there, but sometimes you know for¬†sure¬†that a value isn‚Äôt nil. In these cases, Swift lets you force unwrap the optional: convert it from an optional type to a non-optional type.
For example, if you have a string that contains a number, you can convert it to an¬†Int¬†like this:
That makes¬†num¬†an¬†optional¬†Int¬†because you might have tried to convert a string like ‚ÄúFish‚Äù rather than ‚Äú5‚Äù.
Even though Swift isn‚Äôt sure the conversion will work, you can see the code is safe so you can force unwrap the result by writing¬†!¬†after¬†Int(str), like this:
Swift will immediately unwrap the optional and make¬†num¬†a regular¬†Int¬†rather than an¬†Int?. But if you‚Äôre¬†wrong¬†‚Äì¬†if¬†str¬†was something that couldn‚Äôt be converted to an integer ‚Äì¬†your code will crash.
As a result, you should force unwrap only when you‚Äôre sure it‚Äôs safe ‚Äì¬†there‚Äôs a reason it‚Äôs often called the crash operator.

Like regular optionals, implicitly unwrapped optionals might contain a value or they might be¬†nil. However, unlike regular optionals you don‚Äôt need to unwrap them in order to use them: you can use them as if they weren‚Äôt optional at all.

Implicitly unwrapped optionals are created by adding an exclamation mark after your type name

Because they behave as if they were already unwrapped, you don‚Äôt need¬†if let¬†or¬†guard let¬†to use implicitly unwrapped optionals. However, if you try to use them and they have no value ‚Äì¬†if they are¬†nil‚Äì¬†your code crashes.
Implicitly unwrapped optionals exist because sometimes a variable will start life as nil, but will always have a value before you need to use it. Because you know they will have a value by the time you need them, it‚Äôs helpful not having to write¬†if let¬†all the time.

That being said, if you‚Äôre able to use regular optionals instead it‚Äôs generally a good idea.

The nil coalescing operator unwraps an optional and returns the value inside if there is one. If there¬†isn‚Äôt¬†a value ‚Äì¬†if the optional was¬†nil¬†‚Äì¬†then a default value is used instead. Either way, the result won‚Äôt be optional: it will either by the value from inside the optional or the default value used as a back up.

Here‚Äôs a function that accepts an integer as its only parameter and returns an optional string:

If we call that with ID 15 we‚Äôll get back¬†nil¬†because the user isn‚Äôt recognized, but with nil coalescing we can provide a default value of ‚ÄúAnonymous‚Äù like this:

That will check the result that comes back from the¬†username()¬†function: if it‚Äôs a string then it will be unwrapped and placed into¬†user, but if it has¬†nil¬†inside then ‚ÄúAnonymous‚Äù will be used instead.

Swift provides us with a shortcut when using optionals: if you want to access something like¬†a.b.c¬†and¬†b¬†is optional, you can write a question mark after it to enable¬†optional chaining:¬†a.b?.c.
When that code is run, Swift will check whether¬†b¬†has a value, and if it‚Äôs¬†nil¬†the rest of the line will be ignored ‚Äì¬†Swift will return¬†nil¬†immediately. But if it¬†has¬†a value, it will be unwrapped and execution will continue.

We‚Äôre going to use the¬†first¬†property of that array, which will return the first name if there is one or¬†nil¬†if the array is empty. We can then call¬†uppercased()¬†on the result to make it an uppercase string:

That question mark is optional chaining ‚Äì¬†if¬†first¬†returns¬†nil¬†then Swift won‚Äôt try to uppercase it, and will set¬†beatle¬†to¬†nil¬†immediately.

	still owe: https://www.hackingwithswift.com/sixty/10/8/optional-try

7/11 == 64%
‚Äî


+repeat CLASSES & INT on: https://www.hackingwithswift.com/sixty/8/4/final-classes

day11__F/6/14__Day#11: PROTOCOLS && EXTENSIONS
	session1__730PM ‚úÖ
		
Today you‚Äôre going to learn some truly Swifty functionality: protocols and protocol-oriented programming (POP).
POP does away with large, complex inheritance hierarchies, and replaces them with much smaller, simpler protocols that can be combined together. This really is the fulfillment of something Tony Hoare said many years ago: ‚Äúinside every large program, there is a small program trying to get out.‚Äù

Protocols are a way of describing what properties and methods something must have. You then tell Swift which types use that protocol ‚Äì a process known as adopting or conforming to a protocol.

For example, we can write a function that accepts something with an¬†id¬†property, but we don‚Äôt care precisely what type of data is used. We‚Äôll start by creating an¬†Identifiable¬†protocol, which will require all conforming types to have an¬†id¬†string that can be read (‚Äúget‚Äù) or written (‚Äúset‚Äù):

We can‚Äôt¬†create¬†instances of that protocol -¬†it‚Äôs a description, not a type by itself. But we¬†can¬†create a struct that conforms to it:

One protocol can inherit from another in a process known as¬†protocol inheritance. Unlike with classes, you can inherit from multiple protocols at the same time before you add your own customizations on top.
We‚Äôre going to define three protocols:¬†Payable¬†requires conforming types to implement a¬†calculateWages()¬†method,¬†NeedsTraining¬†requires conforming types to implement a¬†study()method, and¬†HasVacation¬†requires conforming types to implement a¬†takeVacation()¬†method:

Now we can make new types conform to that single protocol rather than each of the three individual ones.

Extensions allow you to add methods to existing types, to make them do things they weren‚Äôt originally designed to do.
For example, we could add an extension to the¬†Int¬†type so that it has a¬†squared()¬†method that returns the current number multiplied by itself:

To try that out, just create an integer and you‚Äôll see it now has a¬†squared()¬†method:

Swift doesn‚Äôt let you add stored properties in extensions, so you must use computed properties instead. For example, we could add a new¬†isEven¬†computed property to integers that returns true if it holds an even number:

Protocols let you describe what methods something should have, but don‚Äôt provide the code inside. Extensions let you provide the code inside your methods, but only affect one data type ‚Äì¬†you can‚Äôt add the method to lots of types at the same time.
Protocol extensions solve both those problems: they are like regular extensions, except rather than extending a specific type like¬†Int¬†you extend a whole protocol so that all conforming types get your changes.
For example, here is an array and a set containing some names:

Both¬†Array¬†and¬†Set¬†will now have that method, so we can try it out:

Protocol extensions can provide default implementations for our own protocol methods. This makes it easy for types to conform to a protocol, and allows a technique called ‚Äúprotocol-oriented programming‚Äù ‚Äì crafting your code around protocols and protocol extensions.
First, here‚Äôs a protocol called¬†Identifiable¬†that requires any conforming type to have an¬†id¬†property and an¬†identify()¬†method:

We¬†could¬†make every conforming type write their own¬†identify()¬†method, but protocol extensions allow us to provide a default:

Now when we create a type that conforms to¬†Identifiable¬†it gets¬†identify()¬†automatically:

You‚Äôve made it to the end of the ninth part of this series, so let‚Äôs summarize:
1. Protocols describe what methods and properties a conforming type must have, but don‚Äôt provide the implementations of those methods.
2. You can build protocols on top of other protocols, similar to classes.
3. Extensions let you add methods and computed properties to specific types such as¬†Int.
4. Protocol extensions let you add methods and computed properties to protocols.
5. Protocol-oriented programming is the practice of designing your app architecture as a series of protocols, then using protocol extensions to provide default method implementations.

	+repeat CLASSES & INH lector‚Äôs
The first difference between classes and structs is that classes never come with a memberwise initializer. This means if you have properties in your class, you must always create your own initializer.

The second difference between classes and structs is that you can create a class based on an existing class ‚Äì¬†it inherits all the properties and methods of the original class, and can add its own on top.
This is called¬†class inheritance¬†or¬†subclassing, the class you inherit from is called the ‚Äúparent‚Äù or ‚Äúsuper‚Äù class, and the new class is called the ‚Äúchild‚Äù class.

However, we can also give¬†Poodle¬†its own initializer. We know it will always have the breed ‚ÄúPoodle‚Äù, so we can make a new initializer that only needs a¬†name¬†property. Even better, we can make the¬†Poodleinitializer call the¬†Dog¬†initializer directly so that all the same setup happens:

For safety reasons, Swift always makes you call¬†super.init()¬†from child classes ‚Äì¬†just in case the parent class does some important work when it‚Äôs created.

Child classes can replace parent methods with their own implementations ‚Äì¬†a process known as¬†overriding. Here‚Äôs a trivial¬†Dog¬†class with a¬†makeNoise()¬†method:

If we create a new¬†Poodle¬†class that inherits from¬†Dog, it will inherit the¬†makeNoise()¬†method. So, this will print ‚ÄúWoof!‚Äù:

Method overriding allows us to change the implementation of¬†makeNoise()¬†for the¬†Poodle¬†class.
Swift requires us to use¬†override func¬†rather than just¬†func¬†when overriding a method ‚Äì¬†it stops you from overriding a method by accident, and you‚Äôll get an error if you try to override something that doesn‚Äôt exist on the parent class:



day10__Th/6/13__Day#10: CLASSES && INHERITENCE
		‚ùå session1__130PM
		session2__4PM	30min‚úÖ
		session3__630PM	30min‚úÖ



Now onto #15== DESIGNATED vs CONVENIENCE init

Just think:
	designated== RETURN OBJ READY TO USE
	convenience== PRECONFIGURED

Onto #14: yeah‚Ä¶

#2== repeat #13 OPTIONALS (CWC)
Recall KEYWORD nil

nil is not a valid integer
nil is not a valid string
nil is meant to represent EMPTINESS

Recall: THINK ? AND !

Int + ? == Int? == OPTIONAL INTEGER == 	Int vs NOTHING
String+? == String? == OPTIONAL STRING	String vs NOTHING

OPTIONALS ARE ALL ABOUT HAVING SOME VALUE VS HAVING NO VALUE

==> ALWAYS CHECK AN OPTIONAL BY UNWRAPPING WITH ! To check if optional contains nil (nothing) or something before using it. YOU CANNOT CALL FXN ON AN EMPTY; you can‚Äôt access something that has no value
	~~~like divining by zero

JUST REMEMBER: BEFORE YOU CAN ACCESS THE OBJECT OF AN OPTIONAL VAR | CONST, YOU MUST FIRST UNWRAP THE OPTIONAL


LIKE A XMAS PRESENT: might have object. Or not. 

! == all about UNWRAPPING, thus creating UNWRAPPED OPTIONAL INT
or UNWRAPPED OPTIONAL STRING

and note: you don‚Äôt have to explicitly declare ‚Äúnil‚Äù for variables && constants. You just need this:

	var t: String?
	var j: String!

//

At first, classes seem very similar to structs because we use them to create new data types with properties and methods. 

However, they introduce a new, important, and¬†complex¬†feature called inheritance ‚Äì ability to make one class build on the foundations of another.

This is a powerful feature, there‚Äôs no doubt about it, and there is no way to avoid using classes when you start building real iOS apps. But please remember to keep your code simple: just because a feature exists, it doesn‚Äôt mean you need to¬†use¬†it. 

As Martin Fowler wrote, ‚Äúany fool can write code that a computer can understand, but good programmers write code that humans can understand.‚Äù

Classes are similar to structs in that they allow you to create new types with properties and methods, but they have five important differences and I‚Äôm going to walk you through each of those differences one at a time.
The first difference between classes and structs is that classes never come with a memberwise initializer. This means if you have properties in your class, you must always create your own initializer.

Creating instances of that class looks just the same as if it were a struct:

The second difference between classes and structs is that you can create a class based on an existing class ‚Äì¬†it inherits all the properties and methods of the original class, and can add its own on top.

Child classes can replace parent methods with their own implementations ‚Äì¬†a process known as¬†overriding. Here‚Äôs a trivial¬†Dog¬†class with a¬†makeNoise()¬†method:

Method overriding allows us to change the implementation of¬†makeNoise()¬†for the¬†Poodle¬†class.
Swift requires us to use¬†override func¬†rather than just¬†func¬†when overriding a method ‚Äì¬†it stops you from overriding a method by accident, and you‚Äôll get an error if you try to override something that doesn‚Äôt exist on the parent class:

	This is called¬†class inheritance¬†or¬†subclassing, the class you inherit from is called the ‚Äúparent‚Äù or ‚Äúsuper‚Äù class, and the new class is called the ‚Äúchild‚Äù class.

Swift gives us a¬†final¬†keyword just for this purpose: when you declare a class as being final, no other class can inherit from it. This means they can‚Äôt override your methods in order to change your behavior ‚Äì they need to use your class the way it was written.
To make a class final just put the¬†final¬†keyword before it,¬†

The third difference between classes and structs is how they are copied. When you copy a struct, both the original and the copy are different things ‚Äì changing one won‚Äôt change the other. When you copy a¬†class, both the original and the copy point to the¬†same¬†thing, so changing one¬†does¬†change the other.
]
Because of the way classes work, both¬†singer¬†and¬†singerCopy¬†point to the same object in memory, so when we print the singer name again we‚Äôll see ‚ÄúJustin Bieber‚Äù:

The fourth difference between classes and structs is that classes can have¬†deinitializers¬†‚Äì¬†code that gets run when an instance of a class is destroyed.

We‚Äôre going to create a few instances of the¬†Person¬†class inside a loop, because each time the loop goes around a new person will be created then destroyed:

And now for the deinitializer. This will be called when the¬†Person¬†instance is being destroyed:

We‚Äôre going to create a few instances of the¬†Person¬†class inside a loop, because each time the loop goes around a new person will be created then destroyed:

The final difference between classes and structs is the way they deal with constants. If you have a constant struct with a variable property, that property can‚Äôt be changed because the struct itself is constant.

However, if you have a constant¬†class¬†with a variable property, that property¬†can¬†be changed. Because of this, classes don‚Äôt need the¬†mutating¬†keyword with methods that change properties; that‚Äôs only needed with structs.

This difference means you can change any variable property on a class even when the class is created as a constant ‚Äì this is perfectly valid code:
If you want to stop that from happening you need to make the property constant:

You‚Äôve made it to the end of the eighth part of this series, so let‚Äôs summarize:
1. Classes and structs are similar, in that they can both let you create your own types with properties and methods.
2. One class can inherit from another, and it gains all the properties and methods of the parent class. It‚Äôs common to talk about class hierarchies ‚Äì¬†one class based on another, which itself is based on another.
3. You can mark a class with the¬†final¬†keyword, which stops other classes from inheriting from it.
4. Method overriding lets a child class replace a method in its parent class with a new implementation.
5. When two variables point at the same class instance, they both point at the same piece of memory ‚Äì¬†changing one changes the other.
6. Classes can have a deinitializer, which is code that gets run when an instance of the class is destroyed.
7. Classes don‚Äôt enforce constants as strongly as structs ‚Äì¬†if a property is declared as a variable, it can be changed regardless of how the class instance was created.


8 of 8		review in future


day9__W/6/12__Day#9: Access control
	‚úÖ	session1__520AM
		session2__3PM

As you‚Äôve seen, structs let us combine individual pieces of data to make something new, then attach methods so we can manipulate that data.
Today you‚Äôre going to learn about some of the more advanced features of structs that make them more powerful, including access control, static properties, and laziness. Yes,¬†laziness¬†‚Äì¬†Bill Gates once said, ‚ÄúI choose a lazy person to do a hard job, Because a lazy person will find an easy way to do it.‚Äù In Swift, laziness is an important performance optimization, as you‚Äôll see.

Initializers are special methods that provide different ways to create your struct. All structs come with one by default, called their¬†memberwise initializer¬†‚Äì this asks you to provide a value for each property when you create the struct.
We can provide our own initializer to replace the default one.¬†
You¬†don‚Äôt¬†write¬†func¬†before initializers, but you¬†do¬†need to make sure all properties have a value before the initializer ends.

Inside methods you get a special constant called¬†self, which points to whatever instance of the struct is currently being used. This¬†self¬†value is particularly useful when you create initializers that have the same parameter names as your property.

For example, if you create a¬†Person¬†struct with a¬†name¬†property, then tried to write an initializer that accepted a¬†name¬†parameter,¬†self¬†helps you distinguish between the property and the parameter ‚Äì¬†self.name¬†refers to the property, whereas¬†name¬†refers to the parameter.

But what if we didn‚Äôt always need the family tree for a particular person? If we add the¬†lazy¬†keyword to the¬†familyTree¬†property, then Swift will only create the¬†FamilyTree¬†struct when it‚Äôs first accessed:

So, if you want to see the ‚ÄúCreating family tree!‚Äù message, you need to access the property at least once:

All the properties and methods we‚Äôve created so far have belonged to individual instances of structs, which means that if we had a¬†Student¬†struct we could create several student instances each with their own properties and methods:

You can also ask Swift to share specific properties and methods across all instances of the struct by declaring them as¬†static.
To try this out, we‚Äôre going to add a static property to the¬†Student¬†struct to store how many students are in the class. Each time we create a new student, we‚Äôll add one to it:
Because the¬†classSize¬†struct belongs to the struct itself rather than instances of the struct, we need to read it using¬†Student.classSize:

Access control lets you restrict which code can use properties and methods. This is important because you might want to stop people reading a property directly, for example.
We could create a¬†Person¬†struct that has an¬†id¬†property to store their social security number:
Once that person has been created, we can make their¬†id¬†be private so you can‚Äôt read it from outside the struct ‚Äì¬†trying to write¬†ed.id¬†simply won‚Äôt work.
Just use the¬†private¬†keyword, like this:
Now only methods inside¬†Person¬†can read the¬†id¬†property. For example:
Another common option is¬†public, which lets all other code use the property or method.

You‚Äôve made it to the end of the seventh part of this series, so let‚Äôs summarize:
1. You can create your own types using structures, which can have their own properties and methods.
2. You can use stored properties or use computed properties to calculate values on the fly.
3. If you want to change a property inside a method, you must mark it as¬†mutating.
4. Initializers are special methods that create structs. You get a memberwise initializer by default, but if you create your own you must give all properties a value.
5. Use the¬†self¬†constant to refer to the current instance of a struct inside a method.
6. The¬†lazy¬†keyword tells Swift to create properties only when they are first used.
7. You can share properties and methods across all instances of a struct using the¬†static¬†keyword.
8. Access control lets you restrict what code can use properties and methods.

Recall private vs public  keyword

2 /6

day8__Tu/6/11__Day#8: STRUCT, PROP 
	‚úÖ	session1__10AM
		session2__330PM

Anyway, today‚Äôs topic is¬†structs. Structs let us create our own data types out of several small types. For example, you might put three strings and a boolean together and say that represents a user in your app.

These custom types ‚Äì¬†users, games, documents, and more ‚Äì¬†form the real core of the software we build. If you get¬†those¬†right then often your code will follow.
As Fred Brooks, the author of the hugely influential book¬†The Mythical Man-Month, once said, ‚Äúthe programmer at wit‚Äôs end... can often do best by disentangling themself from their code, rearing back, and contemplating their data. Representation is the essence of programming.‚Äù

Swift lets you design your own types in two ways, of which the most common are called structures, or just¬†structs. Structs can be given their own variables and constants, and their own functions, then created and used however you want.

Let‚Äôs start with a simple example: we‚Äôre going to create a¬†Sport¬†struct that stores its name as a string. Variables inside structs are called¬†properties, so this is a struct with one property:

That defines the type, so now we can create and use an instance of it:

Properties can have default values just like regular variables, and you can usually rely on Swift‚Äôs type inference.

That has a¬†name¬†property that stores a¬†String. These are called¬†stored¬†properties, because Swift has a different kind of property called a¬†computed¬†property ‚Äì¬†a property that runs code to figure out its value.
We‚Äôre going to add another stored property to the¬†Sport¬†struct, then a computed property. Here‚Äôs how that looks:

As you can see,¬†olympicStatus¬†looks like a regular¬†String, but it returns different values depending on the other properties.
We can try it out by creating a new instance of¬†Sport:

Property observers let you run code before or after any property changes. To demonstrate this, we‚Äôll write a¬†Progress¬†struct that tracks a task and a completion percentage:

We can now create an instance of that struct and adjust its progress over time:
What we¬†want¬†to happen is for Swift to print a message every time¬†amount¬†changes, and we can use a¬†didSet¬†property observer for that. This will run some code every time¬†amount¬†changes:

You can also use¬†willSet¬†to take action¬†before¬†a property changes, but that is rarely used.

Structs can have functions inside them, and those functions can use the properties of the struct as they need to. Functions inside structs are called¬†methods, but they still use the same¬†func¬†keyword.

We can demonstrate this with a¬†City¬†struct. This will have a¬†population¬†property that stores how many people are in the city, plus a¬†collectTaxes()¬†method that returns the population count multiplied by 1000. Because the method belongs to¬†City¬†it can read the current city‚Äôs¬†population¬†property.

That method belongs to the struct, so we call it on instances of the struct like this:

If a struct has a variable property but the instance of the struct was created as a constant, that property can‚Äôt be changed ‚Äì¬†the struct is constant, so all its properties are also constant regardless of how they were created.

The problem is that when you create the struct Swift has no idea whether you will use it with constants or variables, so by default it takes the safe approach: Swift won‚Äôt let you write methods that change properties unless you specifically request it.

When you¬†want¬†to change a property inside a method, you need to mark it using the¬†mutating¬†keyword, like this:

Because it changes the property, Swift will only allow that method to be called on¬†Person¬†instances that are variables:

We‚Äôve used lots of strings so far, and it turns out they are structs ‚Äì¬†they have their own methods and properties we can use to query and manipulate the string.

First, let‚Äôs create a test string:
You can read the number of characters in a string using its¬†count¬†property:
They have a¬†hasPrefix()¬†method that returns true if the string starts with specific letters:
You can uppercase a string by calling its¬†uppercased()¬†method:
And you can even have Swift sort the letters of the string into an array:

Arrays are also structs, which means they too have their own methods and properties we can use to query and manipulate the array.

You can read the number of items in an array using its¬†count¬†property:
If you want to add a new item, use the¬†append()¬†method like this:
You can locate any item inside an array using its¬†firstIndex()¬†method, like this:
That will return 1 because arrays count from 0.
Just like with strings, you can have Swift sort the items of the array alphabetically:
Finally, if you want to remove an item, use the¬†remove()¬†method like this:



Recall the SPECIAL KEYWORD 	didSet {
Recall 	didSet vs. willSet

Recall: nothing happens until you actually call the function



day7__M/6/10__Day#7: CLOSURES II
	‚úÖsession1__2:13PM
	‚úÖsession2__6pm (45min) ==> on lesson 12

Yesterday you learned the basics of closures, but today things get a little trickier. But that‚Äôs OK: Benjamin Franklin once said, ‚Äúenergy and persistence conquer all things‚Äù ‚Äì you can do this!
Sometimes closure syntax can be a bit hard on your eyes. If you find it a bit overwhelming ‚Äì¬†if you‚Äôre staring at some code and aren‚Äôt 100% sure of what it means ‚Äì just go back one video and watch it again.

This is where closures can start to be read a bit like line noise: a closure you pass into a function can also accept its own parameters.
We‚Äôve been using¬†() -> Void¬†to mean ‚Äúaccepts no parameters and returns nothing‚Äù, but you can go ahead and fill the¬†()¬†with the types of any parameters that your closure should accept.
To demonstrate this, we can write a¬†travel()¬†function that accepts a closure as its only parameter, and that closure in turn accepts a string:

We‚Äôve been using¬†() -> Void¬†to mean ‚Äúaccepts no parameters and returns nothing‚Äù, but you can replace that¬†Void¬†with any type of data to force the closure to return a value.
To demonstrate this, we can write a¬†travel()¬†function that accepts a closure as its only parameter, and that closure in turn accepts a string and returns a string:

Swift has a shorthand syntax that lets you go even shorter. Rather than writing¬†place in¬†we can let Swift provide automatic names for the closure‚Äôs parameters. These are named with a dollar sign, then a number counting from 0.

Just to make sure everything is clear, we‚Äôre going to write another closure example using two parameters.
This time our¬†travel()¬†function will require a closure that specifies where someone is traveling to, and the speed they are going. This means we need to use¬†(String, Int) -> String¬†for the parameter‚Äôs type:

We‚Äôre going to call that using a trailing closure and shorthand closure parameter names. Because this accepts two parameters, we‚Äôll be getting both¬†$0¬†and¬†$1:

Some people prefer not to use shorthand parameter names like¬†$0¬†because it can be confusing, and that‚Äôs OK ‚Äì do whatever works best for you.

In the same way that you can pass a closure¬†to¬†a function, you can get closures returned¬†from¬†a function too.
The syntax for this is a bit confusing a first, because it uses¬†->¬†twice: once to specify your function‚Äôs return value, and a second time to specify your closure‚Äôs return value.
To try this out, we‚Äôre going to write a¬†travel()¬†function that accepts no parameters, but returns a closure. The closure that gets returned must be called with a string, and will return nothing.

We can now call¬†travel()¬†to get back that closure, then call it as a function:
It‚Äôs technically allowable ‚Äì¬†although really not recommended! ‚Äì¬†to call the return value from¬†travel()directly:

If you use any external values inside your closure, Swift¬†captures¬†them ‚Äì¬†stores them alongside the closure, so they can be modified even if they don‚Äôt exist any more.
Right now we have a¬†travel()¬†function that returns a closure, and the returned closure accepts a string as its only parameter and returns nothing:
We can call¬†travel()¬†to get back the closure, then call that closure freely:
Closure capturing happens if we create values in¬†travel()¬†that get used inside the closure. For example, we might want to track how often the returned closure is called:
Even though that¬†counter¬†variable was created inside¬†travel(), it gets captured by the closure so it will still remain alive for that closure.
So, if we call¬†result("London")¬†multiple times, the counter will go up and up:




<¬†Previous: Capturing values		Table of Contents¬†>
Closures summary

An error occurred.
Try watching this video on www.youtube.com, or enable JavaScript if it is disabled in your browser.
You‚Äôve made it to the end of the sixth part of this series, so let‚Äôs summarize:
1. You can assign closures to variables, then call them later on.
2. Closures can accept parameters and return values, like regular functions.
3. You can pass closures into functions as parameters, and those closures can have parameters of their own and a return value.
4. If the last parameter to your function is a closure, you can use trailing closure syntax.
5. Swift automatically provides shorthand parameter names like¬†$0¬†and¬†$1, but not everyone uses them.
6. If you use external values inside your closures, they will be captured so the closure can refer to them later.


Eldonde cliffs
Remember, stay accountable: tell the world that you‚Äôve just learned all about closures in Swift, and discuss them with others who are learning too.



day6__Sun/6/9__Day#6: CLOSURES I
	session1__8am
	session2__120PM


Brace yourself, because today we‚Äôre covering the first thing in Swift that many people have hard time understanding. Please keep in mind Flip Wilson's law: ‚Äúyou can't expect to hit the jackpot if you don't put a few nickels in the machine.‚Äù

Sometimes people ask me ‚Äúwhy do you start some topics by saying they are hard ‚Äì aren‚Äôt you just putting people off?‚Äù
Obviously my goal is¬†not¬†to put you off Swift. Instead, my hope is that when you struggle with something you don‚Äôt ever think to yourself ‚ÄúI‚Äôm not cut out for Swift.‚Äù If you find closures hard it‚Äôs¬†not¬†because you aren‚Äôt smart enough ‚Äì¬†they¬†are¬†hard, so it‚Äôs just a sign your brain is working properly.
Don‚Äôt despair. Sometimes fighting to learn something makes it stick in your head better ‚Äì¬†there is no learning without struggle!
You can do this.

Swift lets us use functions just like any other type such as strings and integers. This means you can create a function and assign it to a variable, call that function using that variable, and even pass that function into other functions as parameters.
Functions used in this way are called¬†closures, and although they work like functions they are written a little differently

When you create closures, they don‚Äôt have a name or space to write any parameters. That doesn‚Äôt mean they can‚Äôt¬†accept¬†parameters, just that they do so in a different way: they are listed¬†inside¬†the open braces.

To make a closure accept parameters, list them inside parentheses just after the opening brace, then write¬†in¬†so that Swift knows the main body of the closure is starting.

One of the differences between functions and closures is that you don‚Äôt use parameter labels when running closures

Closures can also return values, and they are written similarly to parameters: you write them inside your closure, directly before the¬†in¬†keyword.

We want a closure that returns a string rather than printing the message directly, so we need to use¬†-> String¬†before¬†in, then use¬†return¬†just like a normal function:

Because closures can be used just like strings and integers, you can pass them into functions. The syntax for this can hurt your brain at first, so we‚Äôre going to take it slow.

If we wanted to pass that closure into a function so it can be run inside that function, we would specify the parameter type as¬†() -> Void. That means ‚Äúaccepts no parameters, and returns¬†Void‚Äù ‚Äì¬†Swift‚Äôs way of saying ‚Äúnothing‚Äù.

If the last parameter to a function is a closure, Swift lets you use special syntax called¬†trailing closure syntax. Rather than pass in your closure as a parameter, you pass it directly after the function inside braces.

In fact, because there aren‚Äôt any other parameters, we can eliminate the parentheses entirely:

This is where closures can start to be read a bit like line noise: a closure you pass into a function can also accept its own parameters.
We‚Äôve been using¬†() -> Void¬†to mean ‚Äúaccepts no parameters and returns nothing‚Äù, but you can go ahead and fill the¬†()¬†with the types of any parameters that your closure should accept.
To demonstrate this, we can write a¬†travel()¬†function that accepts a closure as its only parameter, and that closure in turn accepts a string:


We‚Äôve been using¬†() -> Void¬†to mean ‚Äúaccepts no parameters and returns nothing‚Äù, but you can replace that¬†Void¬†with any type of data to force the closure to return a value.
To demonstrate this, we can write a¬†travel()¬†function that accepts a closure as its only parameter, and that closure in turn accepts a string and returns a string:

Swift has a shorthand syntax that lets you go even shorter. Rather than writing¬†place in¬†we can let Swift provide automatic names for the closure‚Äôs parameters. These are named with a dollar sign, then a number counting from 0.
‚Ä¶


day5__Sat/6/8__Day#5: FUNCTIONS ET AL 
	640am start
	session2_11am
		(6/11) tests == 54%

Functions let us wrap up pieces of code so they can be used in lots of places. We can send data into functions to customize how they work, and get back data that tells us the result that was calculated.
Believe it or not, function calls used to be really slow. Steve Johnson, the author of many early coding tools for the Unix operating system, said this:
‚ÄúDennis Ritchie (the creator of the C programming language) encouraged modularity by telling all and sundry that function calls were really, really cheap in C. Everybody started writing small functions and modularizing. Years later we found out that function calls were still expensive, and our code was often spending 50% of its time just calling them. Dennis had lied to us! But it was too late; we were all hooked...‚Äù

Think, running a function == calling a function 

Functions let us re-use code, which means we can write a function to do something interesting then run that function from lots of places. Repeating code is generally a bad idea, and functions help us avoid doing that.
To start with, we‚Äôre going to write a function that prints help information for users of our app. We might need this anywhere in our app, so having it as a function is a good idea.
Swift functions start with the¬†func¬†keyword, then your function name, then open and close parentheses. All the body of your function ‚Äì the code that should be run when the function is requested ‚Äì is placed inside braces.

Running a function is often referred to as¬†calling¬†a function.

Functions become more powerful when they can be customized each time you run them. Swift lets you send values to a function that can then be used inside the function to change the way it behaves. We‚Äôve used this already ‚Äì¬†we‚Äôve been sending strings and integers to the¬†print()¬†function

Values sent into functions this way are called¬†parameters.
To make your own functions accept parameters, give each parameter a name, then a colon, then tell Swift the type of data it must be. All this goes inside the parentheses after your function name.
For example, we can write a function to print the square of any number:

That tells Swift we expect to receive an¬†Int, and it should be called¬†number. This name is used both inside the function when you want to refer to the parameter, but also when you run the function

As well as receiving data, functions can also send back data. To do this, write a dash then a right angle bracket ( -> ) after your function‚Äôs parameter list, then tell Swift what kind of data will be returned.

Inside your function, you use the¬†return¬†keyword to send a value back if you have one. Your function then immediately exits, sending back that value ‚Äì¬†no other code from that function will be run.

Swift lets us provide two names for each parameter: one to be used externally when calling the function, and one to be used internally inside the function. This is as simple as writing two names, separated by a space.

The parameter is called¬†to name, which means externally it‚Äôs called¬†to, but internally it‚Äôs called¬†name. This gives variables a sensible name inside the function, but means calling the function reads naturally:

You might have noticed that we don‚Äôt actually send any parameter names when we call¬†print()¬†‚Äì we say¬†print("Hello")¬†rather than¬†print(message: "Hello").
You can get this same behavior in your own functions by using an underscore,¬†_, for your external parameter name,¬†


You can now call¬†greet()¬†without having to use the¬†person¬†parameter name:
This can make some code more natural to read, but generally it‚Äôs better to give your parameters external names to avoid confusion.

The¬†print()¬†function prints something to the screen, but always adds a new line to the end of whatever you printed, so that multiple calls to¬†print()¬†don‚Äôt all appear on the same line.
You can change that behavior if you want, so you could use spaces rather than line breaks. Most of the time, though, folks want new lines, so¬†print()¬†has a¬†terminator¬†parameter that uses new line as its default value.
You can give your own parameters a default value just by writing an¬†=¬†after its type followed by the default you want to give it. So, we could write a¬†greet()¬†function that can optionally print nice greetings
That can be called in two ways:

Some functions are¬†variadic, which is a fancy way of saying they accept any number of parameters of the same type. The¬†print()¬†function is actually variadic: if you pass lots of parameters, they are all printed on one line with spaces between them:

You can make any parameter variadic by writing¬†...¬†after its type. So, an¬†Int¬†parameter is a single integer, whereas¬†Int...¬†is zero or more integers ‚Äì potentially hundreds.
Inside the function, Swift converts the values that were passed in to an array of integers, so you can loop over them as needed.
To try this out, let‚Äôs write a¬†square()¬†function that can square many numbers:

Sometimes functions fail because they have bad input, or because something went wrong internally. Swift lets us throw errors from functions by marking them as¬†throws¬†before their return type, then using the¬†throw¬†keyword when something goes wrong.

Swift doesn‚Äôt like errors to happen when your program runs, which means it won‚Äôt let you run an error-throwing function by accident.
Instead, you need to call these functions using three new keywords:¬†do¬†starts a section of code that might cause problems,¬†try¬†is used before every function that might throw an error, and¬†catch¬†lets you handle errors gracefully.

If any errors are thrown inside the¬†do¬†block, execution immediately jumps to the¬†catch¬†block. Let‚Äôs try calling¬†checkPassword()¬†with a parameter that throws an error:

When that code runs, ‚ÄúYou can‚Äôt use that password‚Äù is printed, but ‚ÄúThat password is good‚Äù won‚Äôt be ‚Äì¬†that code will never be reached, because the error is thrown.

You‚Äôve made it to the end of the fifth part of this series, so let‚Äôs summarize:
1. Functions let us re-use code without repeating ourselves.
2. Functions can accept parameters ‚Äì¬†just tell Swift the type of each parameter.
3. Functions can return values, and again you just specify what type will be sent back. Use tuples if you want to return several things.
4. You can use different names for parameters externally and internally, or omit the external name entirely.
5. Parameters can have default values, which helps you write less code when specific values are common.
6. Variadic functions accept zero or more of a specific parameter, and Swift converts the input to an array.
7. Functions can throw errors, but you must call them using¬†try¬†and handle errors using¬†catch.
8. You can use¬†inout¬†to change variables inside a function, but it‚Äôs usually better to return a new value.




day4__F/6/7__Day#4: LOOPS
	session2_5pm

	===remember to complete the tests

Swift has a few ways of writing loops, but their underlying mechanism is the same: run some code repeatedly until a condition evaluates as false.
The most common loop in Swift is a¬†for¬†loop: it will loop over arrays and ranges, and each time the loop goes around it will pull out one item and assign to a constant.

We can use a¬†for¬†loop to print each item.

If you don‚Äôt use the constant that¬†for¬†loops give you, you should use an underscore instead so that Swift doesn‚Äôt create needless value.

Remember: don‚Äôt get tripped up on the forward vs backslash bullshit

Recall: it‚Äôs, \ , FORWARD SLASH, OPEN PARENTHESIS‚Ä¶
\ ( ) 

	‚Äî>onto WHILE LOOPS

A second way of writing loops is using¬†while: give it a condition to check, and its loop code will go around and around until the condition fails.
For example, we could use a¬†while¬†loop to simulate a child counting in a game of hide and seek: we start at one, count up to and including 20 while printing each number out, then after the loop print ‚ÄúReady or not‚Äù.

The third way of writing loops is not commonly used, but it‚Äôs so simple to learn we might as well cover it: it‚Äôs called the¬†repeat¬†loop, and it‚Äôs identical to a¬†while¬†loop except the condition to check comes at the end.

Because the condition comes at the¬†end¬†of the¬†repeat¬†loop the code inside the loop will always be executed at least once, whereas¬†while¬†loops check their condition before their first run.

You can exit a loop at any time using the¬†break¬†keyword.

With that change, as soon as¬†countDown¬†reaches 4 the astronaut‚Äôs message will be printed, and the rest of the loop gets skipped.

If you put a loop inside a loop it‚Äôs called a¬†nested¬†loop, and it‚Äôs not uncommon to want to break out of both the inner loop and the outer loop at the same time.

As you‚Äôve seen, the¬†break¬†keyword exits a loop. But if you just want to skip the current item and continue on to the next one, you should use¬†continue¬†instead.

To try this out, we can write a loop from 1 through 10, then use Swift‚Äôs remainder operator to skip any numbers that are odd:

Remember, the remainder operator figures out how many times 2 fits into each number in our loop, then returns whatever is left over. So, if 1 is left over, it means the number is odd, so we can use¬†continue¬†to skip it.

It‚Äôs common to use¬†while¬†loops to make¬†infinite¬†loops:¬†loops that either have no end or only end when you‚Äôre ready. All apps on your iPhone use infinite loops, because they start running, then continually watch for events until you choose to quit them.

To make an infinite loop, just use¬†true¬†as your condition.¬†true¬†is always true, so the loop will repeat forever.¬†Warning:¬†Please make sure you have a check that exits your loop, otherwise it will never end.

You‚Äôve made it to the end of the fourth part of this series, so let‚Äôs summarize:
1. Loops let us repeat code until a condition is false.
2. The most common loop is¬†for, which assigns each item inside the loop to a temporary constant.
3. If you don‚Äôt need the temporary constant that¬†for¬†loops give you, use an underscore instead so Swift can skip that work.
4. There are¬†while¬†loops, which you provide with an explicit condition to check.
5. Although they are similar to¬†while¬†loops,¬†repeat¬†loops always run the body of their loop at least once.
6. You can exit a single loop using¬†break, but if you have nested loops you need to use¬†break followed by whatever label you placed before your outer loop.
7. You can skip items in a loop using¬†continue.
8. Infinite loops don‚Äôt end until you ask them to, and are made using¬†while true. Make sure you have a condition somewhere to end your infinite loops!


/=/=/=


Loops are one of the things that make computers so utterly brilliant: the ability to repeat some simple task billions of times every second.
Of course, what¬†goes¬†in those loops is down to you: you might be adding some numbers, you might be reading some sensor data, or you might be redrawing the screen 120 times a second. As Craig Bruce said, ‚Äúit‚Äôs hardware that makes a machine fast, but it‚Äôs software that makes a fast machine slow.‚Äù



day4__F/6/7__Day#3: OPERATORS & CONDITIONS

Swift has several operators that perform comparison, and these work more or less like you would expect in mathematics.

There are two operators that check for equality:¬†==¬†checks two values are the same, and¬†!=(pronounced ‚Äúnot equals‚Äù) checks two values are¬†not¬†the same.

here are four operators for comparing whether one value is greater than, less than, or equal to another.¬†

Each of these also work with strings, because strings have a natural alphabetical order

Now you know some operators you can write conditions using¬†if¬†statements. You give Swift a condition, and if that condition is true it will run code of your choosing.
To try this out, I want to use a Swift function called¬†print(): you run it with some text, and it will be printed out.

The code inside the braces ‚Äì¬†{¬†and¬†}¬†‚Äì¬†will be printed if the condition is true. If you want you can provide alternative code to run if the condition is¬†false, using¬†else.

You can also chain conditions together using¬†else if.

Swift has two special operators that let us combine conditions together: they are¬†&&¬†(pronounced ‚Äúand‚Äù) and¬†||¬†(pronounced ‚Äúor‚Äù).

That¬†print()¬†call will only happen if both ages are over 18, which they aren‚Äôt. In fact, Swift won‚Äôt even bother checking the value of¬†age2¬†because it can see that¬†age1¬†already failed the test.
The alternative to¬†&&¬†is¬†||, which evaluates as true if either item passes the test.¬†

You can use¬†&&¬†and¬†||¬†more than once in a single condition, but don‚Äôt make things too complicated otherwise it can be hard to read!

Swift has a rarely used operator called the ternary operator. It works with three values at once, which is where its name comes from: it checks a condition specified in the first value, and if it‚Äôs true returns the second value, but if its false returns the third value.
The ternary operator is a condition plus true or false blocks all in one, split up by a question mark and a colon, all of which which makes it rather hard to read.¬†

That checks whether the two cards are the same, then prints ‚ÄúCards are the same‚Äù if the condition is true, or ‚ÄúCards are different‚Äù if it‚Äôs false.

If you have several conditions using¬†if¬†and¬†else if, it‚Äôs often clearer to use a different construct known as¬†switch case. Using this approach you write your condition once, then list all possible outcomes and what should happen for each of them.


The last case ‚Äì¬†default¬†‚Äì¬†is required because Swift makes sure you cover all possible cases so that no eventuality is missed off. If the weather is anything other than rain, snow, or sun, the¬†default¬†case will be run.

Swift will only run the code inside each case. If you want execution to continue on to the next case, use the¬†fallthrough¬†keyword like this:

Swift gives us two ways of making ranges: the¬†..<¬†and¬†...¬†operators. The half-open range operator,¬†..<, creates ranges up to but excluding the final value, and the closed range operator,¬†..., creates ranges up to and¬†including¬†the final value.
For example, the range¬†1..<5¬†contains the numbers 1, 2, 3, and 4, whereas the range¬†1...5¬†contains the numbers 1, 2, 3, 4, and 5.

As before, the¬†default¬†case must be there to ensure all possible values are covered.

Recall that SWITCH must be exhaustive

You‚Äôve made it to the end of the third part of this series, so let‚Äôs summarize:
1. Swift has operators for doing arithmetic and for comparison; they mostly work like you already know.
2. There are compound variants of arithmetic operators that modify their variables in place:¬†+=,¬†-=, and so on.
3. You can use¬†if,¬†else, and¬†else if¬†to run code based on the result of a condition.
4. Swift has a ternary operator that combines a check with true and false code blocks. Although you might see it in other code, I wouldn‚Äôt recommend using it yourself.
5. If you have multiple conditions using the same value, it‚Äôs often clearer to use¬†switch¬†instead.
6. You can make ranges using¬†..<¬†and¬†...¬†depending on whether the last number should be excluded or included.
‚úÖ


day3__Th/6/6/__Day#3: OPERATORS & CONDITIONS
1:40PM start XXX
3:30PM start XXX
10:30PM start
Passed out during module 4‚Ä¶woke up 1:30am


Now you know all the basic types in Swift, we can start to put them together using operators. Operators are those little matematical symbols like¬†+¬†and¬†-
Swift supports operator overloading, which is a fancy way of saying that what an operator does depends on the values you use it with.

Remember, Swift is a type-safe language, which means it won‚Äôt let you mix types. For example, you can‚Äôt add an integer to a string because it doesn‚Äôt make any sense.

Swift has shorthand operators that combine one operator with an assignment, so you can change a variable in place. These look like the existing operators you know ‚Äì¬†+,¬†-,¬†*, and¬†/, but they have an¬†=on the end because they assign the result back to whatever variable you were using.



/-/-

Sometimes you need to be able to assign values to enums so they have meaning. This lets you create them dynamically, and also use them in different ways.
Swift will automatically assign each of those a number starting from 0, and you can use that number to create an instance of the appropriate enum case.
If you want, you can assign one or more cases a specific value, and Swift will generate the rest. It‚Äôs

You‚Äôve made it to the end of the second part of this series, so let‚Äôs summarize:
1. Arrays, sets, tuples, and dictionaries let you store a group of items under a single value. They each do this in different ways, so which you use depends on the behavior you want.
2. Arrays store items in the order you add them, and you access them using numerical positions.
3. Sets store items without any order, so you can‚Äôt access them using numerical positions.
4. Tuples are fixed in size, and you can attach names to each of their items. You can read items using numerical positions or using your names.
5. Dictionaries store items according to a key, and you can read items using those keys.
6. Enums are a way of grouping related values so you can use them without spelling mistakes.
7. You can attach raw values to enums so they can be created from integers or strings, or you can add associated values to store additional information about each case.




day2__W/6/5__Day#2: ARRAYS et all
Start 3:20

Arrays are collections of values that are stored as a single value. For example, John, Paul, George, and Ringo are names, but arrays let you group them in a single value called The Beatles.

That last line makes the array: it starts and ends with brackets, with each item in the array separated by a comma.
You can read values from an array by writing a number inside brackets. Array positions count from 0, so if you want to read ‚ÄúPaul McCartney‚Äù you would write this:

Be careful: Swift crashes if you read an item that doesn‚Äôt exist.

Note:¬†If you‚Äôre using type annotations, arrays are written in brackets:¬†[String],¬†[Int],¬†[Double], and¬†[Bool].


Sets are collections of values just like arrays, except they have two differences:
1. Items aren‚Äôt stored in any order; they are stored in what is effectively a random order.
2. No item can appear twice in a set; all items must be unique.

When you look at the value of¬†colors¬†inside the playground output you‚Äôll see it doesn‚Äôt match the order we used to create it. It‚Äôs not really a¬†random¬†order, it‚Äôs just¬†unordered¬†‚Äì Swift makes no guarantees about its order. 
	bc they are unordered, you can‚Äôt read values from a set using numerical positions 
	like you can with arrays.
	If you try to insert a duplicate item into a set, the duplicates get ignored.

Tuples allow you to store several values together in a single value. That might sound like arrays, but tuples are different:
1. You can‚Äôt add or remove items from a tuple; they are fixed in size.
2. You can‚Äôt change the type of items in a tuple; they always have the same types they were created with.
3. You can access items in a tuple using numerical positions or by naming them, but Swift won‚Äôt let you read numbers or names that don‚Äôt exist.

Tuples are created by placing multiple items into parentheses,¬†

You then access items using numerical positions starting from 0
Or you can access items using their names

Remember, you can change the values inside a tuple after you create it, BUT NOT the¬†types¬†of values. So, if you tried to change¬†name¬†to be¬†(first: "Justin", age: 25)¬†you would get an error.

Arrays, sets, and tuples can seem similar at first, but they have distinct uses. To help you know which to use, here are some rules.
	If you need a specific, FIXED collection of related values where each item has a 	precise position or name, you should use a tuple

	If you need a collection of values that must be UNIQUE or you need to be able to 	check whether a specific item is in there extremely quickly, you should use a set

	If you need a collection of values that can contain duplicates, or the ORDER of 	your items MATTERS, you should use an array


Dictionaries are collections of values just like arrays, but rather than storing things with an integer position you can access them using anything you want.
The most common way of storing dictionary data is using strings. For example, we could create a dictionary that stores the height of singers using their name

Just like arrays, dictionaries start and end with brackets and each item is separated with a comma. However, we also use a colon to separate the value you want to store (e.g. 1.78) from the identifier you want to store it under (e.g. ‚ÄúTaylor Swift‚Äù).

These identifiers are called¬†keys, and you can use them to read data back out of the dictionary

When using type annotations, dictionaries are written in brackets with a colon between your identifier and value types. For example,¬†[String: Double]¬†and¬†[String: String].

If you try to read a value from a dictionary using a key that doesn‚Äôt exist, Swift will send you back¬†nil¬†‚Äì¬†nothing at all. While this might be what you want, there‚Äôs an alternative: we can provide the dictionary with a default value to use if we request a missing key.

But if we tried reading the favorite ice cream for Charlotte, we‚Äôd get back nil, meaning that Swift doesn‚Äôt have a value for that key
We can fix this by giving the dictionary a default value of ‚ÄúUnknown‚Äù, so that when no ice cream is found for Charlotte we get back ‚ÄúUnknown‚Äù rather than nil

Arrays, sets, and dictionaries are called¬†collections, because they collect values together in one place.
If you want to create an¬†empty¬†collection just write its type followed by opening and closing parentheses.¬†

The exception is creating an empty set, which is done differentl
This is because Swift has special syntax only for dictionaries and arrays; other types must use angle bracket syntax like sets.


Enumerations ‚Äì usually called just¬†enums¬†‚Äì are a WAY OF DEFINING groups of related values in a way that makes them easier to use.
For example, if you wanted to write some code to represent the success or failure of some work you were doing, you could represent that as strings

But what happens if someone accidentally uses different naming?


All those three are different strings, so they mean different things.
With enums we can define a¬†Result¬†type that can be either¬†success¬†or¬†failure, like this:

And now when we use it we must choose one of those two values:
This stops you from accidentally using different strings each time.

As well as storing a simple value, enums can also STORE ASSOCIATED VALUES attached to each case. This lets you attach additional information to your enums so they can represent more nuanced data.

That lets us say that someone is talking, but we don‚Äôt know what they talking¬†about, or we can know that someone is running, but we don‚Äôt know where they are running¬†to.
Enum associated values let us add those additional details


Now we can be more precise ‚Äì we can say that someone is talking about football:

Sometimes you need to be able to assign values to enums so they have meaning. This lets you create them dynamically, and also use them in different ways.

==============================

==============================

day1__Tu/6/4__Day#1: VAR et al

variables, which are places where you can store program data.
	called variables because they can¬†vary¬†‚Äì¬†you can change their values freely.

Because¬†str¬†is a variable we can change it:
We don‚Äôt need¬†var¬†the second time because the variable has already been created ‚Äì we‚Äôre just changing it.

Swift is what‚Äôs known as a type-safe language, which means that every variable must be of one specific type. The¬†str¬†variable that Xcode created for us holds a string of letters that spell ‚ÄúHello, playground‚Äù, so Swift assigns it the type¬†String

Variables can hold a whole number, so Swift assigns the TYPE¬†Int¬†‚Äì¬†short for ‚Äúinteger‚Äù.
	If you have large numbers, Swift lets you use underscores as thousands separators ‚Äì¬†they don‚Äôt change the number, but they do make it easier to read
Strings and integers are different types, and they can‚Äôt be mixed. So, while it‚Äôs safe to change¬†str¬†to ‚ÄúGoodbye‚Äù, I can‚Äôt make it 38 because that‚Äôs an¬†Int¬†not a¬†String.


Standard Swift strings use double quotes, but you can‚Äôt include line breaks in there.
	If you want multi-line strings you need slightly different syntax: 
	start and end with three double quote marks """

	Swift is very particular about how you write those quote marks: the opening and 	closing triple must be on their own line, but that opening and closing line breaks 	won‚Äôt be included in your final string.

If you only want multi-line strings to format your code neatly, and you don‚Äôt want those line breaks to actually be in your string, end each line with a¬†\, like this:

***escaped new line on the final line is not allowed

Two other basic types of data in Swift are doubles and booleans

	‚ÄúDouble‚Äù is short for ‚Äúdouble-precision floating-point number‚Äù, fancy way of 
	saying it holds fractional values such as 38.1, or 3.141592654.

Whenever you create a variable with a fractional number, Swift automatically gives that variable the type¬†Double

Doubles are different from integers, and you can‚Äôt mix them.

booleans are much simpler: they just hold either true or false; 
	Swift will automatically assign the boolean type to any variable assigned either true or false as its value


Swift also has a feature called STRING INTERPOLATION ‚Äì the ability to place variables inside your strings to make them more useful.

You can place any type of variable inside your string ‚Äì¬†all you have to do is write a backslash,¬†\, followed by your variable name in parentheses.¬†
As you‚Äôll see later on, string interpolation isn‚Äôt just limited to placing variables ‚Äì¬†you can actually run code inside there.

variables have that name bc their values can change over time, and that is often useful. However, very often you want to set a value once and never change it, and so we have an alternative to the¬†var¬†keyword called¬†let.

let¬†keyword creates¬†constants, which are values that can be set once and never again

Swift assigns each variable and constant a type based on what value it‚Äôs given when it‚Äôs created. Ie:
	let str = ‚Äúhello world!‚Äù

That will make¬†str¬†a string, so you can‚Äôt try to assign it an integer or a boolean later on. This is called¬†type inference: Swift is able to infer the type of something based on how you created it.

If you want you can be explicit about the type of your data rather than relying on Swift‚Äôs type inference,¬†

Notice that booleans have the short type name¬†Bool, in the same way that integers have the short type name¬†Int.

	***Use constants as often as possible***

You‚Äôve made it to the end of the first part of this series, so let‚Äôs summarize.
1. You make variables using¬†var¬†and constants using¬†let. It‚Äôs preferable to use constants as often as possible.
2. Strings start and end with double quotes, but if you want them to run across multiple lines you should use three sets of double quotes.
3. Integers hold whole numbers, doubles hold fractional numbers, and booleans hold true or false.
4. String interpolation allows you to create strings from other variables and constants, placing their values inside your string.
5. Swift uses type inference to assign each variable or constant a type, but you can provide explicit types if you want.


==> part2:
	https://www.raywenderlich.com/ios/learn
