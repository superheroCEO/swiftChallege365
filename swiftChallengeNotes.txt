113 SWIFT CHALLENGE (code for 113 days consecutively)

"Rise, let us be on our way"

â€œLucious is safeâ€
The more you type, the more practice.
"I can do all things through Christ, who strengthens me."
	ONLY BY ACTUALLY TYPING IN SWIFT CODE TO YOU BEGIN TO GRASP IT


	https://www.hackingwithswift.com/100
	https://codewithchris.com/swift-tutorial-resources/

******
******
day36__T/7/9/_Day22: App Brewery (Dr. Angela)	
545am start time
715am end time
(90min) COMPLETEâœ…âœ…âœ…
******
******


When using cocao pods, have to use WORKSPACE file (contains pods)
//MARK:  --> to separate code into discrete sections

Recall:		OPTION + hoverOver
		+import CoreLocation
		+ClLocationManagerDelegate
		+let locationManager = CLLocationManager()  [creating new object]
						*note: initialized w/no parameters

"WeatherViewController subclass of UIViewController that CONFORMS to RULES of CLLMDelegate"

locationManager.delegate = self ==> "refer to location manager ==> access delegate property via dot notation ==> set to self (WeatherViewController)
[ we set ourselves at the delegate == the current ViewController ] 

Asynchronous method == works in background (vs working in foreground)
Only interested in most accurate location ~last value collected
		
		---> via [locations.count - 1]
		to convert to String ---> String(input)

If want to use Location Manager code, have to set delegate, class that will handle data
	View Controller == "I will be the delegate"

Dictionary holds data via key-value pair (order not important like arrays)
Dictionary retrieves data via key in key-value pair

Recall:		arrays && index positioning

THINK:		CINEMA CLOAKROOM EXAMPLE

	-->	let latitude = params["lat"]
		let longitude = params["lon"]

Arrays && dictionary == collection types == help organize data

What are APIs?
******
******
day35__M/7/8/_Day21: App Brewery (Dr. Angela)	
545am start time
715am end time
(90min) COMPLETEâœ…âœ…âœ…

230pm session2
(60min) COMPELTEâœ…âœ…
******
******


Weâ€™re going to introduce you to the wonderful world of Cocoapods and open source libraries.
Additionally, weâ€™ll learn how to call Application Programming Interfaces (APIs) to grab data from websites.

Cocoapods == dependency manager for Swift; tons of libraries (collections of code)

VERY IMPORTANT HOW YOU EDIT PODFILE

POD INSTALL FLOW

	pod init
	open -a Xcode Podfile
		delete # ---> + rq pods

	pod 'SwiftyJSON'
	pod 'Alamofire'
	pod 'SVProgressHUD'
	pod --version
	pod install
	(pod update)


--
recall: 	viewDidLoad
		we know we inherit viewDidLoad() from UIViewController, but we want to 
		OVERRIDE it's fxn, and + our own fxn
		use of dot notation to access fxn


Trying to OVERRIDE (add on) to existing fxn?
KEYWORD:	super --> refers to Super class inherited from
		ie super class of SelfDrivingCar == Car

1st== 	carry out fxn from Car()
		" super.drive() " 
2nd==	add on new fxn for SelfDrivingCar


1) INHERIT fxn from superclass
2) OVERRIDE fxn to add on new fxn

"" vs NO DATA (nil)
nil/null pointer error
? == "could contain a nil value" (done at creation stage== declaring var/constants)
? == "could have a value, or not"
! == to FORCE UNWRAP OPTIONAL for use
! == serves as MANUAL OVERRIDE ("definitely does not have a value")

OPTIONAL BINDING
	check to see if declared variable/constant definitely has a value
	SYNTAX	if let
		let to create new constant
		if to check 
		print between { } ONLY gets executed when declared variable IS NOT NIL 
		(has a value)

Using optional binding, don't have to force unwrap (dangerous)
IF LET safer

RECALL		variables as boxes
	only when unwrap box: value or not?
	? == could contain value or not
		ie var destination: String?	[ String optional data type here]
	! == to FORCE UNWRAP
		ie var destination: String! 	["I know has value & not nil]
	
OPTIONAL BINDING== shake the box first (check to see IF has value)
	String vs Optional String data type
	data types have counterpart OPTIONAL (?) data type
	! == force unwrapping (ie converts from String? --> String)

IF LET
	safer way
	ONLY WHEN NOT NIL, execute declared code w/I braces { }

		if let userSetDestination = destination {
			print("driving towards " + userSetDestination)
		}
	===> "if let newConstantDeclared equal to value of Optional
		if optional has value, execute print statement
		if destination == NIL == CHECK NOT PASSED == print not executed		 
	
******
******
day34__Sun/7/7/_Day20: App Brewery (Dr. Angela)	
640am start time
8am end time
(60min) COMPLETEâœ…âœ…

8pm session2
(30min) COMPLETEâœ…
******
******

Recall:	Animal Kingdom INHERITANCE example

	class Mammals: Animals {
	var hasHair: True
}
	class Birds: Animals {
	func canFly() {}
}
	class Humans: Mammals {
	func useComputer() {}
}

SUBCLASSES INHERIT FROM SUPERCLASS && INHERIT IT'S PROPERTIES && FXN

Recall:
	open && close parenthesis () when creating new object instances
	ONLY BY ACTUALLY TYPING IN SWIFT CODE TO YOU BEGIN TO GRASP IT

KEYWORD: 
	override == in order to OVERRIDE existing fxn from inherited class

SWIFT CONVENTION: declare override keyword BEFORE func
	ie 	override func viewDidLoad() { }
		super.breathe() == do all fxn of breath(), but also + new fxn
RECALL:
	class ViewController: UIViewController {}
		ViewController INHERITS UIViewController fxn


	override func viewDidLoad() {
		super.viewDidLoad()

		updateUI()
	}
		===>	super.viewDidLoad() == refers to SUPER class of viewDidLoad == UIViewController; load up viewDidLoad, but then add new fxn [ updateUI() ]

--
Enums allow for custom data types instead of using something ambiguous like, "1, 2, 3"
Note open && close parenthesis () when creating new Class
What are the various properties of our newly created object?

What if we want a SPECIAL car beyond the STANDARD setting?
Option 1: custom initializer
init: "a set of statements that prepares AN INSTANCE of a class, structure, enumeration for use"
What happens when init METHOD triggered?
Note previous Car Class declaration had no parameter input

	Programming: predicting your outcome, comparing expectations, debugging

INITIALIZER ALLOW YOU TO OVERRIDE DEFAULT SET PROPERTIES
init METHOD is an EVENT (point in program where object gets created, "initialized")

Designated vs convenience initializer 
	Designated init (default one) has compulsory parameters that require an input 		(cannot ignore)
	Convenience init == an optional initializer 
	"self. " ---> refers to own class
Designated init w/ DEFAULT setting vs Convenience init w/optional Custom setting
Convenience init == an add-on

Note:	position of func when declaring it
	dot notation allows access of Variable properties && Methods
	V == Variable, M == Method
	COMMAND + S whenever possible in Swift

If func declared w/I class == METHOD
METHOD ALWAYS ASSOCIATED W/AN OBJECT

Note:	you specify inheritance w/I Class declaration via COLON (:)


******
******
day33__Sat/7/6/_Day19: App Brewery (Dr. Angela)	
645am start time
830am end time
(90min) COMPLETEEâœ…âœ…âœ…

345pm session2
(30min) COMPLETEâœ…
******
******

Classes == blueprints for creating objects w/certain properties
KEYWORDS always in pink
When creating new classes, new swift file required. Ensure TARGETS checkbox accurate
Class CONVENTION == first letter Capitalized
First thing's first: add the properties

ENUMs are about creating CUSTOM DATA TYPES.
SWIFT CONVENTION:

	enum(s) declared at top 
	enums Capitalized via camelcase ie enum CarType
	cases w/I enums NOT CAPITALIZED. But first letter property is.
	enum structure:
		enum CarType {
			case One
			case Two
			case Three
		}


dot notation to access Case types
Enumerations && setting buttons titles(!) 

Buttons use the Target-Action design pattern to notify your app when the user taps the button. Rather than handle touch events directly, you assign action methods to the button and designate which events trigger calls to your methods. At runtime, the button handles all incoming touch events and calls your methods in response.

---
Note use of OPTION + DRAG (to copy UI elements)
Stacking UI elements together
Equal distribution
Points of spacing between UI elements
Horizontal vs vertical stacking
Clearing constrains; re-adding
Use of Equal Widths
Use of multipliers with stack views (ie 1:2.1)
Achieving padding by modifying stack view, "align trailing to"


******
******
day32__F/7/5/_Day18: App Brewery (Dr. Angela)	
730am start time
900am end time
(90min) COMPLETEâœ…âœ…âœ…
******
******

How to make designs look great across all devices, and/or orientation?
1) programmatically 
2) AUTO LAYOUT via setting constraints - rules for program to abide by 


viewDidLoad == cycle of app where view first gets displayed for user
UIView == class (blueprint)
CG == CoreGraphics
by default, UIViews are transparent; need to set background color property to make visual for user
(x: 0, y: 0) == refers to TOP LEFT-HAND CORNER position
Need to determine height/width of screen when positioning objects
self.view.frame.width/2 == refers to current view controller
The larger the screen, the larger the screen w/H

Constraints allow us to set rules as to how we want our views to be displayed. Because mobile screens have different resolutions and sizes, we need these rules to tell the iPhone/iPad how it should layout the display. These rules allow our UI elements to be resized and positioned so that no matter which screen they are displayed on, they always look as the designer intended.

FLOW
	Uncheck constraints to margin button
Order matters
Instead of constraining to margins (default setting), constrain to edge of screen
Clearing constraints on current view element view entire view (~RESET BUTTON)
Pinning vs alignment method (and/or)
Introducing CONTAINERS to hold views
Sibling vs child relationships
nesting
"Inside a folder vs creating a folder"
4 zeroes contraints
"Always position this way inside the container"
"Pin this edge, pin this edge"
0 refers to closest element neighbor
Create containers that will always evenly distribute
Background color to default == colorless


******
******


One of the most important steps to take in order to make the jump from
learner coder to a fully fledged programmer is understanding how to get
help. Everyone needs help. Everyone, including those so-called â€œGod Level
Programmersâ€

But what you do with the help will determine how fast you progress as a
coder. On a site like StackOverflow, it can be very tempting to just copy and
paste the code that someone has provided. 

exercise didnâ€™t teach you anything other than code reliance. 

same code snippet that someone provided may not work anymore. Then
what do you do? Youâ€™re stuck

 thereâ€™s a rule in programming that says â€œnever copypaste code
that you donâ€™t understandâ€. So what should you do when youâ€™re confronted
with a block of code that solves your problem but you have no clue how it
works? Break it down.

Step 1 - Copy and paste the code
Step 2 - Make sure that your program or application is functioning as
expected.
Step 3 - Delete the copy and pasted block of code LINE BY LINE.
Step 4 - Each time you delete a line, check to see whatâ€™s been broken. Does
the app still run? What are the error codes? What has deleting that line of
code done to your program?
 most important task as a programmer is to always test your
assumptions against the outcome. For the most enjoyable feeling as a
programmer is for the real world to validate your assumptions. 
â€œYou were rightâ€.
Itâ€™s like that, but better.
Step 6 - Swap some of the lines around. Can the same functionality be
achieved with a different order of lines? Why were they written in the order
they were written in?
By breaking the solution code, line-by-line, youâ€™ll learn and understand what
each line does and why itâ€™s been written. This is a far better way to use code
from other people than just pasting it in and hoping for the best. 
Think about the structure of their program. Take a look at all the classes,
the constants, the interplay. Make some modifications to the code. Does it
still work or have you broken it? Why did you break it? Is there a link that
you didnâ€™t identify? Ask yourself a bunch of questions, learn through the
SOCRATIC METHOD. Tear down the project and understand how it was built.

When you start getting really good at this, the next thing you can try is
reverse engineering. Find a small project on GitHub made by a reputable
programmer, download the app. Run it and see all of its functionality. Play
around with it.
Then build it from scratch and once youâ€™re done, compare your code to their
code. Are there efficiency gains that you could have made? Are there
solutions to things you couldnâ€™t figure out? Now youâ€™re really getting into the
big leagues.



******
******
day31__Th/7/4/_Day17: App Brewery (Dr. Angela)	
630am start time
800am end time
(90min) COMPLETEâœ…âœ…âœ…
******
******

RECALL If-else clauses work like as such:
	if (condition 1) {
		statement1;
	} else if (condition2) {
		statement2;
	} else {
		statement3;
}


RECALL use of pseudo code
	"if topButton was pressed {
		change the storyTextView to story 3
		change the topButtonTitle to answer3a
		change the bottomButtonTitle to answer3b
	} "	


First: 	what going to make? 
	what UI elements are required?
	IF sender.tag == 1 vs sender.tag == 2 THEN
		want to CHECK IF sender.tag is 1 vs 2
		everything given sender.tag = 0 by default

dot notation to access properties

Recall 
	use of ELSE IF
	use of || or operator
	use of .isHidden = true vs false for button property

THINK:	a number to define where user is? (Track them/progress)
	where is user?
	what button did user press?
	reassigning of variables


COMMAND A ---> OPTION + CONTROL + I == align text

In VIM
	In the text editor, press computer's i key to edit the file (place in INSERT MODE)
	after editing, press ESC (will put vim in COMMAND MODE)
	to save, type :w
	to exit, type :q
	to save && exit, type	:wq
	to discard changes, type :q!


******
******
day30__W/7/3/_Day16: App Brewery (Dr. Angela)    
1pm start time
COMPLETE
******
******

The goal of this tutorial is to get you comfortable with thinking about the state of your app and updating the Views accordingly. In addition, you will be using logic to control the flow of the program. This is a challenge where youâ€™ll solidify your understanding of IF-ELSE statements and comparison operators.

app will tell a story depending on what the user chooses and can be fleshed out and modified to provide an engaging story-telling experience

think:
    //our strings/constants/var
    //UI Elements linked to storyboard
    //initializing variables
    //User presses button(s)    (triggering IBAction)
        The â€œsenderâ€ in the brackets refers to the button that triggered the IBAction
        need the tag property to distinguish WHO TRIGGERED the IBAction. 
        can do this by checking sender.tag
            if sender.tag == 1...
            if sender.tag == 2...

creating empty text file in shell (bash!)
	touch foo.txt	==	>>foo.txt
	touch ~/Downloads/newTay.txt

Recall
	echo "Hello Taylor Alison Swift" >13fortaylor.txt
	echo "Hello Taylor" > ~/Downloads/somethingElse.txt

short answer:
	terminal = tty = text input/output environment
	console = physical terminal
	shell = command line interpreter
   

Buttons have a state because they can be pressed, highlighted, or disabled. Each may have different appearances or titles. Apple says we should set the value for the normal state at minimum

To figure out which route the user should take, got to use the TAG associated w/buttons.

Recall logic operators:
	== to test EQUALITY.
	E.g. (someValue == 5) tests â€œIs someValue equal to five?"

&& single = sign used for ASSIGNMENT 
	i.e. something = 3. 


Keeping track of state

&& --> logical AND operator
	(storyIndex > 3 && storyIndex < 5) tests â€œIs storyIndex greater than three AND is 	storyIndex smaller than five?â€
|| --> logical OR operator. 
	(storyIndex == 3 || storyIndex == 4) tests â€œIs storyIndex equal to three OR is 		storyIndex equal to four?â€

When the user gets to the stories without answers, you can hide the buttons using the syntax:  buttonName.isHidden = true


On macOS systems, the configuration file is found at â€œ/private/etc/ssh/ssh_config,â€ which is symlinked to â€œ/etc/ssh/ssh_configâ€ for compatibility.

A second, user-specific ssh_config is found at â€œ~/.ssh/ssh_config.â€ If it exists, this file supersedes the system-wide configuration file. This file sets user-specific options without changing the systemâ€™s configuration.

touch foo.txt


******
******
day29_tu/7/2_day15: App Brewery (Dr. Angela)
10pm start time
COMPLETE
******
******

Recall use of +=
		score += 1 --> score = score + 1

Where does it make sense for this to happen?
Escaping a string
Declaring a function vs calling function
Does code work as expected?
Variables as state trackers	

How can we give the user feedback?
No console for user
Print statements == only developer sees
Power of 3rd party libraries 
	"HUD == Heads Up Display" visual (objective-C code)
	note bridging header creates
3 steps to use code:
	1) git clone repo
	2) drag/drop 3 files into Supporting Files folder
	3) "#import ProgressHUD.h" ---> BRIDGING HEADER file
ProgressHUD dot notation
NO POINT IN REINVENTING THE WHEEL

REVISITING COMMAND LINE
	-repo
	-commit
	-branch
	-merge
	-fork
	-pull request

commands:
	cd	pwd	ls	cd... 	clear	open . 	ls -all
	cd + drag folder
	power of tab && autocomplete


Starting out, maybe easier to create folder on GITHUB --> clone
	vs using git init


	git clone
	git status
	git commit -a
	git commit -a -m "Creating new file"

Get git error? "You can suppress this message by..."

	git config --global user.name "Your Name"
	git config --global user.email 
	git config --list
	git log
	git log -2

VIM!	(terminal based)

	" : q "	 IF GET STUCK IN VIM

	git push
	git pull
	git remote
	git remote -v
		"remote" == duplicate instance of your repo that lives on github.com

	
	git push origin 
			ORIGIN JUST THE DEFAULT NAME git use when cloning repo

	git push origin master
	
	git init --> turn it into an empty git repo
	
Idea of staging

3 steps
	1) save file
	2) add it
	3) commit it

	git commit -a 	(add it && commit it)
	git commit filename.txt	vs	git commit -a (all files)

IF STARTING ON GITHUB: remote already associated
vs.
IF STARTING LOCALLY, HAVE TO CREATE REMOTE

	git remote
	git remote -v
	git remote add origin ("add a remote named origin" == convention)
	git remote add origin <URL>
	git pull origin master

Generate new SSH

	hidden .ssh folder



day28__M/7/1/_Day14: App Brewery (Dr. Angela)	
ON #106â€¦.

	 âœ…âœ…1pm
	session2 
When you see real programmers working. They tend to look like this:
Yep, thatâ€™s right. No typing. Just staring. A lot of staring. For thereâ€™s a bug, thereâ€™s always a bug. Other people might not understand, but in these situations, itâ€™s almost always worth stepping away from your code and giving it some time and distance. Do you have a bug in your code that you canâ€™t work out? Sleep on it, play foosball, go for a walk. In 9 out of 10 cases, the solution will become apparent. In the remaining 1 out of 10 cases, youâ€™re just screwed. So remember, the easiest code to get rid of is the code that was never written.

Assigning vs eauality	( =  vs. == )
Utility of sender tags
Code looks inside braces, â€œwhat should I do?â€
Creating vs calling a method
Knowlege layers; honesty; progression; forward, review, back, pause, repeat, 

Var created on top 
Using variable to keep track of STATE	(ie state of which Q user is on)
In programming, donâ€™t get to blame anyone else but yourself

Note use of lldb in debug console; and print X var
Can leverage print to guide your debugging
There will be flaws in your logic; bugs in your code

modal alerts
Action sheets for for bottom
IF see in, think SELF
	


day27__Sun/6/30/_Day13: App Brewery (Dr. Angela)	
	âœ…845pm 
	QUIZ app again

	info.plist file == think KEY : PAIR	XML 
		short for property list (stores config info at runtime 
		similar to dictionary, KEY is the property name && VALUE is the 			configuration
	COMMAND + .  == STOP SIM
	importing libraries == Swiss army knives
	MODEL folder for storing data 
	when declaring classes ==> CAPITAL first letter
	properties are variables associated w/a class
	a METHOD is a FXN associated w/a CLASS
	when you initialize, you give a starting value. Possible?
	init()  â€”>. A METHOD. The Init Method determines what happens when new OBJECTS are created from this class
	classes == blueprint

	MVC model == think Restaurant analogy
	class: blueprint == instructions 
	OBJECTS ARE CREATED FROM CLASSES
	objects have properties (constant/var), Events (fxn) && Actions 
	Events == how to respond to things
	init() used to define an event (what happens when new Q are created)

	
	init() empty
	
	CONTROLLER HANDLES COMMUNICATION BETWEEN MODEL && VIEW
	MODEL: manger that manages data
	restaurant analogy
	CONTROLLER controls what get displayed on screen
	think FLOW of obj
	why implement MVC? 1) provide structure 2) collaboration 3) CODE REUSE 4) allow multi-tasking


	

day26__Sat/6/29/_Day12: App Brewery (Dr. Angela)	
	âœ…10am= start 
	520pm session 2

	learnxinyminutes.com
	https://www.youtube.com/watch?v=0fKg7e37bQE
	(GitHub)
	gitclone <URL>
`	git status
	git add  <fileName>
	git add . 		(everything in directory)
	git add -A	â€œ
	git commit (locking it ) -m (giving message, but on my machine)
	git push	(send to the cloud)
	git pull
	git	(all commands)

Actual flow:
	git pull
		my changes
			git add -A 	(All)
				git commit -m
					git push
	esc 
		:wq

Repository | repo
Start gitHub â€”> command line
the. commit. hash. ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥

Branching
oull request		up to reviewer to accept vs reject
Merge 
Fork
	
	cd	pwd		ls		clear		open . 
	up/down arrows
	cd SPACE (drag folder)
	ls -all

	




day24__F/6/28/_Day12: App Brewery (Dr. Angela)	
	âœ…5am= start 
	11am session 2


day23__TH6/27/_Day11: App Brewery (Dr. Angela)	
	âœ…7p=m start 
day22__W/6/26/_Day10: App Brewery (Dr. Angela)	
	âœ…530am start 
	7:30pm session 2

	property list == .plist	file stores config info at runtime
	info stored in format == key-value pair
	(similar to dictionary, key == property name, value== config)

	MVC== model, view, controller
	model == where data model stored
	import libraries == like Swiss army knives
	when declaring classes,  first letter always CAPITAL
	properties are variables associated w/a class
	method is a fxn associated w/a class
	method vs fxn
	init() { } â€”> when you initialize, you give starting values
	classes == blueprints (from which objects are created from)
	init() method

	review notes/ + from last 2 vids

Jeff Goodell:Â Would you explain, in simple terms, exactly what object-oriented software is?
Steve Jobs:Â Objects are like people. Theyâ€™re living, breathing things that have knowledge inside them about how to do things and have memory inside them so they can remember things. And rather than interacting with them at a very low level, you interact with them at a very high level of abstraction, like weâ€™re doing right here.
Hereâ€™s an example: If Iâ€™m your laundry object, you can give me your dirty clothes and send me a message that says, â€œCan you get my clothes laundered, please.â€ I happen to know where the best laundry place in San Francisco is. And I speak English, and I have dollars in my pockets. So I go out and hail a taxicab and tell the driver to take me to this place in San Francisco. I go get your clothes laundered, I jump back in the cab, I get back here. I give you your clean clothes and say, â€œHere are your clean clothes.â€
You have no idea how I did that. You have no knowledge of the laundry place. Maybe you speak French, and you canâ€™t even hail a taxi. You canâ€™t pay for one, you donâ€™t have dollars in your pocket. Yet, I knew how to do all of that. And you didnâ€™t have to know any of it. All that complexity was hidden inside of me, and we were able to interact at a very high level of abstraction. Thatâ€™s what objects are. They encapsulate complexity, and the interfaces to that complexity are high level.



94501

(REV HERE==>)	day22__Tu/6/25/_Day9: App Brewery (Dr. Angela)	
	âœ…âœ…630am start (45min)
	âœ…713pm session2

	Import AVFoundation â€”> declare class â€”> define var

	DO CATCH TRY == ERROR CATCHING

	do {
}
	catch {
}
	executing this method can THROW an ERROR


osstatus.com  		(ERROR CODES)

`	â€œ ! â€œ == serves as MANUAL override
Ie	
	instead of do {} && catch { } blocks
		â€”> try! 

	define FUNC after IB ACTIONSâ€¦
	
	sender.tag utility 

	arrays start counting from 0

	tags are given by default
	
	â€œsender.tag - 1â€
	
	think: problem with hard coded data
	
	scope

	local vs global variables == ACCESSIBILITY 

	setting empty variables s/a : String = â€œâ€ (empty string!

/-/-/
	scope is about visibility of var
	LOCAL VAR only visible w/I curly braces
	THINK GRADEN APPLE TREE EXAMPLE
		only you can access vs everyone can access
		placement w/I wall vs communal

	func w/INPUTS (parameters)

	GLOBAL > LOCAL VAR
		whenever possible, try to avoid using global variables. 
		whenever possible, keep the apple tree in your own garden

	


day21__M/6/24/_Day8: App Brewery (Dr. Angela)	
	âœ…1030am start
	âœ…1413pm session2

	sum += number is the equivalent of
		sum = sum + number

	for constant in arrayOfNumbers THINK single digit of XYZ 
Recall:
	for number in 1...10 {	(inclusive of 10)
	vs
	for number in 1..<10 {	(DOES NOT INCLUE 10)

	use of % MODULO REMAINDER

	ie number % 2 == 0 	== â€œdivides cleanly into 2, thus must be evenâ€
	3 % 2 â€”> 1
	4 % 2 â€”> 0
	5 % 2 â€”> 1
	13 %2 â€”> 1

	keywords: 	FOR		IN		WHERE

	\n (â€œbackslash nâ€)	==> CREATES NEW LINE
	+ before == new line
	+ end of line == big empty space

	for number in (1â€¦99).reversed() {â€¨}
	(until X :  Int )

	if not using keyword in FOR IN loops, replace w/ underscore â€œ_ â€œ
Ie:
	for iteration in 0â€¦n {} ==> for _ in 0â€¦n {}

	do catch blocks (for catching errors: try thisâ€¦if error, print out this statement
	hold down OPTION key / command key too

projectEuler.net
stackoverflow.com
Forums.developer.apple.com
developer.apple.com/reference


day20__Sun/6/23/_Day7: App Brewery (Dr. Angela)	
	âœ…715am start 

IF ELSE: think. forest:
	walking. 
	On left side IF ARROW
	on right side ELSE ARROW. 
	Straight down center (and at slight down angle) ELSE IF ARROW

On fxn:
	think: INPUT_OUTPUT_INSTRUCTION (IOI)

And remember, call, the, function. 
Swift not read right to left like English.


day19__S/6/22/_Day6: App Brewery (Dr. Angela)	
	âœ…630am start 

Recall COMMAND + / 


day18__F/6/21__Day5: App Brewery (Dr. Angela)
	âœ…613am start 

GOOGLE â€œxyz Apple Documentationâ€

This is the most important part of learning to code. Itâ€™s much like cooking. You can learn to make cakes with recipes in the beginning, but you only become a chef when you start making your own creations without a recipe. 
	Right now, donâ€™t aim for 3 Michelin stars. Aim for edible.

day17__Th/6/20__Day4: App Brewery (Angela)
	âœ…630am start session1
Recall:
	-var & constants CONTAINERS for data
	-var == data can be swapped in/out of container
	-let (constant) == data CANNOT be changed

Think of a box. 
	Constant == 1 data item == close box. 
	Variable == OPEN box == variable items



day16__W/6/19__Day3: App Brewery (Angela)

	âœ…7am start session1
	2pm session2 (30min)

day15__Tu/6/18__Day2: App Brewery (Angela)
âœ…745am start session1
	https://www.appbrewery.co/
	flatuicolors.com
	appicon.co
	canva.com


day14__M/6/17__Day1: App Brewery (Angela)

	Learning to code is a bit like going to the gym. Even if you max out and spent a whole weekend at the gym, you will not see a visible difference in your body. The more regularly you learn to code, the more likely it is that youâ€™ll start seeing your ripped coding muscles. 
	left me with only 9 hours remaining in my day. 
	Theoretically, 2 hours could be allocated to coding practice and 7 hours on sleep. But there is nothing more difficult than trying to convince your work-saturated brain to sit down and learn when you could be watching Game of Thrones with a tub of ice-cream.
	First, you must understand that task-switching is very difficult. It requires a lot of motivation. If as soon as you get home, you slump on the sofa and switch on the TV, youâ€™ve already lost that evening. This is because the amount of motivation required to task-switch and do something not driven by evolution like eating or sleeping is a Herculean task.


day13__Sun/6/16__Day#12: OPTIONALS &&

still owe: https://www.hackingwithswift.com/sixty/10/8/optional-try
7/11 == 64%â€¨
That runs a throwing function, usingÂ do,Â try, andÂ catchÂ to handle errors gracefully.
There are two alternatives toÂ try, both of which will make more sense now that you understand optionals and force unwrapping.
The first isÂ try?, and changes throwing functions into functions that return an optional. If the function throws an error youâ€™ll be sentÂ nilÂ as the result, otherwise youâ€™ll get the return value wrapped as an optional.

When talking about force unwrapping, I used this code:
let str = "5"
let num = Int(str)
That converts a string to an integer, but because you might try to pass any string there what you actually get back is anÂ optionalÂ integer.
This is aÂ failable initializer: an initializer that might work or might not. You can write these in your own structs and classes by usingÂ init?()Â rather thanÂ init(), and returnÂ nilÂ if something goes wrong. The return value will then be an optional of your type, for you to unwrap however you want.
As an example, we could code aÂ PersonÂ struct that must be created using a nine-letter ID string. If anything other than a nine-letter string is used weâ€™ll returnÂ nil, otherwise weâ€™ll continue as normal.
Hereâ€™s that in Swift:

Youâ€™ve made it to the end of the tenth part of this series, so letâ€™s summarize:
1. Optionals let us represent the absence of a value in a clear and unambiguous way.
2. Swift wonâ€™t let us use optionals without unwrapping them, either usingÂ if letÂ or usingÂ guard let.
3. You can force unwrap optionals with an exclamation mark, but if you try to force unwrapÂ nilÂ your code will crash.
4. Implicitly unwrapped optionals donâ€™t have the safety checks of regular optionals.
5. You can use nil coalescing to unwrap an optional and provide a default value if there was nothing inside.
6. Optional chaining lets us write code to manipulate an optional, but if the optional turns out to be empty the code is ignored.
7. You can useÂ try?Â to convert a throwing function into an optional return value, orÂ try!Â to crash if an error is thrown.
8. If you need your initializer to fail when itâ€™s given bad input, useÂ init?()Â to make a failable initializer.
9. You can use typecasting to convert one type of object to another.

Recall: guard must be followed by else

day12__Sat/6/15__Day#11: OPTIONALS &&

Null references â€“Â literally when a variable has no value â€“Â were invented by Tony Hoare way back in 1965. When asked about it in retrospect, he said â€œI call it my billion-dollar mistakeâ€ because they lead to so many problems.

This is the last day that youâ€™ll be learning the fundamentals of Swift, and itâ€™s devoted exclusively to Swiftâ€™s solution to null references, known asÂ optionals. These are a really important language feature, but they can hurt your brain a little â€“Â donâ€™t feel bad if you need to repeat some videos a few times.

Weâ€™ve used types such asÂ IntÂ to hold values like 5. But if you wanted to store anÂ ageÂ property for users, what would you do if you didnâ€™t know someoneâ€™s age?

You might say â€œwell, Iâ€™ll store 0â€, but then you would get confused between new-born babies and people whose age you donâ€™t know. You could use a special number such as 1000 or -1 to represent â€œunknownâ€, both of which are impossible ages, but then would you really remember that number in all the places itâ€™s used?

Swiftâ€™s solution is calledÂ optionals, and you can make optionals out of any type. An optional integer might have a number like 0 or 40, but it might have no value at all â€“Â it might literally be missing, which isÂ nilÂ in Swift.
To make a type optional, add a question mark after it.Â 

Optional strings might contain a string like â€œHelloâ€ or they might be nilÂ â€“ nothing at all.

What happens if we useÂ name.count? A real string has aÂ countÂ property that stores how many letters it has, but this isÂ nilÂ â€“Â itâ€™s empty memory, not a string, so it doesnâ€™t have aÂ count.

Because of this, trying to readÂ name.countÂ is unsafe and Swift wonâ€™t allow it. Instead, we must look inside the optional and see whatâ€™s thereÂ â€“ a process known asÂ unwrapping.

A common way of unwrapping optionals is withÂ if letÂ syntax, which unwraps with a condition. If there was a value inside the optional then you can use it, but if there wasnâ€™t the condition fails.

IfÂ nameÂ holds a string, it will be put insideÂ unwrappedÂ as a regularÂ StringÂ and we can read itsÂ countproperty inside the condition. Alternatively, ifÂ nameÂ is empty, theÂ elseÂ code will be run.

An alternative toÂ if letÂ isÂ guard let, which also unwraps optionals.Â guard letÂ will unwrap an optional for you, but if it findsÂ nilÂ inside it expects you to exit the function, loop, or condition you used it in.

However, the major difference betweenÂ if letÂ andÂ guard letÂ is that your unwrapped optional remains usable after theÂ guardÂ code.

Letâ€™s try it out with aÂ greet()Â function. This will accept an optional string as its only parameter and try to unwrap it, but if thereâ€™s nothing inside it will print a message and exit. Because optionals unwrapped usingÂ guard letÂ stay around after theÂ guardÂ finishes, we can print the unwrapped string at the end of the function:

UsingÂ guard letÂ lets you deal with problems at the start of your functions, then exit immediately. This means the rest of your function is the happy path â€“ the path your code takes if everything is correct.

Optionals represent data that may or may not be there, but sometimes you know forÂ sureÂ that a value isnâ€™t nil. In these cases, Swift lets you force unwrap the optional: convert it from an optional type to a non-optional type.
For example, if you have a string that contains a number, you can convert it to anÂ IntÂ like this:
That makesÂ numÂ anÂ optionalÂ IntÂ because you might have tried to convert a string like â€œFishâ€ rather than â€œ5â€.
Even though Swift isnâ€™t sure the conversion will work, you can see the code is safe so you can force unwrap the result by writingÂ !Â afterÂ Int(str), like this:
Swift will immediately unwrap the optional and makeÂ numÂ a regularÂ IntÂ rather than anÂ Int?. But if youâ€™reÂ wrongÂ â€“Â ifÂ strÂ was something that couldnâ€™t be converted to an integer â€“Â your code will crash.
As a result, you should force unwrap only when youâ€™re sure itâ€™s safe â€“Â thereâ€™s a reason itâ€™s often called the crash operator.

Like regular optionals, implicitly unwrapped optionals might contain a value or they might beÂ nil. However, unlike regular optionals you donâ€™t need to unwrap them in order to use them: you can use them as if they werenâ€™t optional at all.

Implicitly unwrapped optionals are created by adding an exclamation mark after your type name

Because they behave as if they were already unwrapped, you donâ€™t needÂ if letÂ orÂ guard letÂ to use implicitly unwrapped optionals. However, if you try to use them and they have no value â€“Â if they areÂ nilâ€“Â your code crashes.
Implicitly unwrapped optionals exist because sometimes a variable will start life as nil, but will always have a value before you need to use it. Because you know they will have a value by the time you need them, itâ€™s helpful not having to writeÂ if letÂ all the time.

That being said, if youâ€™re able to use regular optionals instead itâ€™s generally a good idea.

The nil coalescing operator unwraps an optional and returns the value inside if there is one. If thereÂ isnâ€™tÂ a value â€“Â if the optional wasÂ nilÂ â€“Â then a default value is used instead. Either way, the result wonâ€™t be optional: it will either by the value from inside the optional or the default value used as a back up.

Hereâ€™s a function that accepts an integer as its only parameter and returns an optional string:

If we call that with ID 15 weâ€™ll get backÂ nilÂ because the user isnâ€™t recognized, but with nil coalescing we can provide a default value of â€œAnonymousâ€ like this:

That will check the result that comes back from theÂ username()Â function: if itâ€™s a string then it will be unwrapped and placed intoÂ user, but if it hasÂ nilÂ inside then â€œAnonymousâ€ will be used instead.

Swift provides us with a shortcut when using optionals: if you want to access something likeÂ a.b.cÂ andÂ bÂ is optional, you can write a question mark after it to enableÂ optional chaining:Â a.b?.c.
When that code is run, Swift will check whetherÂ bÂ has a value, and if itâ€™sÂ nilÂ the rest of the line will be ignored â€“Â Swift will returnÂ nilÂ immediately. But if itÂ hasÂ a value, it will be unwrapped and execution will continue.

Weâ€™re going to use theÂ firstÂ property of that array, which will return the first name if there is one orÂ nilÂ if the array is empty. We can then callÂ uppercased()Â on the result to make it an uppercase string:

That question mark is optional chaining â€“Â ifÂ firstÂ returnsÂ nilÂ then Swift wonâ€™t try to uppercase it, and will setÂ beatleÂ toÂ nilÂ immediately.

	still owe: https://www.hackingwithswift.com/sixty/10/8/optional-try

7/11 == 64%
â€”


+repeat CLASSES & INT on: https://www.hackingwithswift.com/sixty/8/4/final-classes

day11__F/6/14__Day#11: PROTOCOLS && EXTENSIONS
	session1__730PM âœ…
		
Today youâ€™re going to learn some truly Swifty functionality: protocols and protocol-oriented programming (POP).
POP does away with large, complex inheritance hierarchies, and replaces them with much smaller, simpler protocols that can be combined together. This really is the fulfillment of something Tony Hoare said many years ago: â€œinside every large program, there is a small program trying to get out.â€

Protocols are a way of describing what properties and methods something must have. You then tell Swift which types use that protocol â€“ a process known as adopting or conforming to a protocol.

For example, we can write a function that accepts something with anÂ idÂ property, but we donâ€™t care precisely what type of data is used. Weâ€™ll start by creating anÂ IdentifiableÂ protocol, which will require all conforming types to have anÂ idÂ string that can be read (â€œgetâ€) or written (â€œsetâ€):

We canâ€™tÂ createÂ instances of that protocol -Â itâ€™s a description, not a type by itself. But weÂ canÂ create a struct that conforms to it:

One protocol can inherit from another in a process known asÂ protocol inheritance. Unlike with classes, you can inherit from multiple protocols at the same time before you add your own customizations on top.
Weâ€™re going to define three protocols:Â PayableÂ requires conforming types to implement aÂ calculateWages()Â method,Â NeedsTrainingÂ requires conforming types to implement aÂ study()method, andÂ HasVacationÂ requires conforming types to implement aÂ takeVacation()Â method:

Now we can make new types conform to that single protocol rather than each of the three individual ones.

Extensions allow you to add methods to existing types, to make them do things they werenâ€™t originally designed to do.
For example, we could add an extension to theÂ IntÂ type so that it has aÂ squared()Â method that returns the current number multiplied by itself:

To try that out, just create an integer and youâ€™ll see it now has aÂ squared()Â method:

Swift doesnâ€™t let you add stored properties in extensions, so you must use computed properties instead. For example, we could add a newÂ isEvenÂ computed property to integers that returns true if it holds an even number:

Protocols let you describe what methods something should have, but donâ€™t provide the code inside. Extensions let you provide the code inside your methods, but only affect one data type â€“Â you canâ€™t add the method to lots of types at the same time.
Protocol extensions solve both those problems: they are like regular extensions, except rather than extending a specific type likeÂ IntÂ you extend a whole protocol so that all conforming types get your changes.
For example, here is an array and a set containing some names:

BothÂ ArrayÂ andÂ SetÂ will now have that method, so we can try it out:

Protocol extensions can provide default implementations for our own protocol methods. This makes it easy for types to conform to a protocol, and allows a technique called â€œprotocol-oriented programmingâ€ â€“ crafting your code around protocols and protocol extensions.
First, hereâ€™s a protocol calledÂ IdentifiableÂ that requires any conforming type to have anÂ idÂ property and anÂ identify()Â method:

WeÂ couldÂ make every conforming type write their ownÂ identify()Â method, but protocol extensions allow us to provide a default:

Now when we create a type that conforms toÂ IdentifiableÂ it getsÂ identify()Â automatically:

Youâ€™ve made it to the end of the ninth part of this series, so letâ€™s summarize:
1. Protocols describe what methods and properties a conforming type must have, but donâ€™t provide the implementations of those methods.
2. You can build protocols on top of other protocols, similar to classes.
3. Extensions let you add methods and computed properties to specific types such asÂ Int.
4. Protocol extensions let you add methods and computed properties to protocols.
5. Protocol-oriented programming is the practice of designing your app architecture as a series of protocols, then using protocol extensions to provide default method implementations.

	+repeat CLASSES & INH lectorâ€™s
The first difference between classes and structs is that classes never come with a memberwise initializer. This means if you have properties in your class, you must always create your own initializer.

The second difference between classes and structs is that you can create a class based on an existing class â€“Â it inherits all the properties and methods of the original class, and can add its own on top.
This is calledÂ class inheritanceÂ orÂ subclassing, the class you inherit from is called the â€œparentâ€ or â€œsuperâ€ class, and the new class is called the â€œchildâ€ class.

However, we can also giveÂ PoodleÂ its own initializer. We know it will always have the breed â€œPoodleâ€, so we can make a new initializer that only needs aÂ nameÂ property. Even better, we can make theÂ Poodleinitializer call theÂ DogÂ initializer directly so that all the same setup happens:

For safety reasons, Swift always makes you callÂ super.init()Â from child classes â€“Â just in case the parent class does some important work when itâ€™s created.

Child classes can replace parent methods with their own implementations â€“Â a process known asÂ overriding. Hereâ€™s a trivialÂ DogÂ class with aÂ makeNoise()Â method:

If we create a newÂ PoodleÂ class that inherits fromÂ Dog, it will inherit theÂ makeNoise()Â method. So, this will print â€œWoof!â€:

Method overriding allows us to change the implementation ofÂ makeNoise()Â for theÂ PoodleÂ class.
Swift requires us to useÂ override funcÂ rather than justÂ funcÂ when overriding a method â€“Â it stops you from overriding a method by accident, and youâ€™ll get an error if you try to override something that doesnâ€™t exist on the parent class:



day10__Th/6/13__Day#10: CLASSES && INHERITENCE
		âŒ session1__130PM
		session2__4PM	30minâœ…
		session3__630PM	30minâœ…



Now onto #15== DESIGNATED vs CONVENIENCE init

Just think:
	designated== RETURN OBJ READY TO USE
	convenience== PRECONFIGURED

Onto #14: yeahâ€¦

#2== repeat #13 OPTIONALS (CWC)
Recall KEYWORD nil

nil is not a valid integer
nil is not a valid string
nil is meant to represent EMPTINESS

Recall: THINK ? AND !

Int + ? == Int? == OPTIONAL INTEGER == 	Int vs NOTHING
String+? == String? == OPTIONAL STRING	String vs NOTHING

OPTIONALS ARE ALL ABOUT HAVING SOME VALUE VS HAVING NO VALUE

==> ALWAYS CHECK AN OPTIONAL BY UNWRAPPING WITH ! To check if optional contains nil (nothing) or something before using it. YOU CANNOT CALL FXN ON AN EMPTY; you canâ€™t access something that has no value
	~~~like divining by zero

JUST REMEMBER: BEFORE YOU CAN ACCESS THE OBJECT OF AN OPTIONAL VAR | CONST, YOU MUST FIRST UNWRAP THE OPTIONAL


LIKE A XMAS PRESENT: might have object. Or not. 

! == all about UNWRAPPING, thus creating UNWRAPPED OPTIONAL INT
or UNWRAPPED OPTIONAL STRING

and note: you donâ€™t have to explicitly declare â€œnilâ€ for variables && constants. You just need this:

	var t: String?
	var j: String!

//

At first, classes seem very similar to structs because we use them to create new data types with properties and methods. 

However, they introduce a new, important, andÂ complexÂ feature called inheritance â€“ ability to make one class build on the foundations of another.

This is a powerful feature, thereâ€™s no doubt about it, and there is no way to avoid using classes when you start building real iOS apps. But please remember to keep your code simple: just because a feature exists, it doesnâ€™t mean you need toÂ useÂ it. 

As Martin Fowler wrote, â€œany fool can write code that a computer can understand, but good programmers write code that humans can understand.â€

Classes are similar to structs in that they allow you to create new types with properties and methods, but they have five important differences and Iâ€™m going to walk you through each of those differences one at a time.
The first difference between classes and structs is that classes never come with a memberwise initializer. This means if you have properties in your class, you must always create your own initializer.

Creating instances of that class looks just the same as if it were a struct:

The second difference between classes and structs is that you can create a class based on an existing class â€“Â it inherits all the properties and methods of the original class, and can add its own on top.

Child classes can replace parent methods with their own implementations â€“Â a process known asÂ overriding. Hereâ€™s a trivialÂ DogÂ class with aÂ makeNoise()Â method:

Method overriding allows us to change the implementation ofÂ makeNoise()Â for theÂ PoodleÂ class.
Swift requires us to useÂ override funcÂ rather than justÂ funcÂ when overriding a method â€“Â it stops you from overriding a method by accident, and youâ€™ll get an error if you try to override something that doesnâ€™t exist on the parent class:

	This is calledÂ class inheritanceÂ orÂ subclassing, the class you inherit from is called the â€œparentâ€ or â€œsuperâ€ class, and the new class is called the â€œchildâ€ class.

Swift gives us aÂ finalÂ keyword just for this purpose: when you declare a class as being final, no other class can inherit from it. This means they canâ€™t override your methods in order to change your behavior â€“ they need to use your class the way it was written.
To make a class final just put theÂ finalÂ keyword before it,Â 

The third difference between classes and structs is how they are copied. When you copy a struct, both the original and the copy are different things â€“ changing one wonâ€™t change the other. When you copy aÂ class, both the original and the copy point to theÂ sameÂ thing, so changing oneÂ doesÂ change the other.
]
Because of the way classes work, bothÂ singerÂ andÂ singerCopyÂ point to the same object in memory, so when we print the singer name again weâ€™ll see â€œJustin Bieberâ€:

The fourth difference between classes and structs is that classes can haveÂ deinitializersÂ â€“Â code that gets run when an instance of a class is destroyed.

Weâ€™re going to create a few instances of theÂ PersonÂ class inside a loop, because each time the loop goes around a new person will be created then destroyed:

And now for the deinitializer. This will be called when theÂ PersonÂ instance is being destroyed:

Weâ€™re going to create a few instances of theÂ PersonÂ class inside a loop, because each time the loop goes around a new person will be created then destroyed:

The final difference between classes and structs is the way they deal with constants. If you have a constant struct with a variable property, that property canâ€™t be changed because the struct itself is constant.

However, if you have a constantÂ classÂ with a variable property, that propertyÂ canÂ be changed. Because of this, classes donâ€™t need theÂ mutatingÂ keyword with methods that change properties; thatâ€™s only needed with structs.

This difference means you can change any variable property on a class even when the class is created as a constant â€“ this is perfectly valid code:
If you want to stop that from happening you need to make the property constant:

Youâ€™ve made it to the end of the eighth part of this series, so letâ€™s summarize:
1. Classes and structs are similar, in that they can both let you create your own types with properties and methods.
2. One class can inherit from another, and it gains all the properties and methods of the parent class. Itâ€™s common to talk about class hierarchies â€“Â one class based on another, which itself is based on another.
3. You can mark a class with theÂ finalÂ keyword, which stops other classes from inheriting from it.
4. Method overriding lets a child class replace a method in its parent class with a new implementation.
5. When two variables point at the same class instance, they both point at the same piece of memory â€“Â changing one changes the other.
6. Classes can have a deinitializer, which is code that gets run when an instance of the class is destroyed.
7. Classes donâ€™t enforce constants as strongly as structs â€“Â if a property is declared as a variable, it can be changed regardless of how the class instance was created.


8 of 8		review in future


day9__W/6/12__Day#9: Access control
	âœ…	session1__520AM
		session2__3PM

As youâ€™ve seen, structs let us combine individual pieces of data to make something new, then attach methods so we can manipulate that data.
Today youâ€™re going to learn about some of the more advanced features of structs that make them more powerful, including access control, static properties, and laziness. Yes,Â lazinessÂ â€“Â Bill Gates once said, â€œI choose a lazy person to do a hard job, Because a lazy person will find an easy way to do it.â€ In Swift, laziness is an important performance optimization, as youâ€™ll see.

Initializers are special methods that provide different ways to create your struct. All structs come with one by default, called theirÂ memberwise initializerÂ â€“ this asks you to provide a value for each property when you create the struct.
We can provide our own initializer to replace the default one.Â 
YouÂ donâ€™tÂ writeÂ funcÂ before initializers, but youÂ doÂ need to make sure all properties have a value before the initializer ends.

Inside methods you get a special constant calledÂ self, which points to whatever instance of the struct is currently being used. ThisÂ selfÂ value is particularly useful when you create initializers that have the same parameter names as your property.

For example, if you create aÂ PersonÂ struct with aÂ nameÂ property, then tried to write an initializer that accepted aÂ nameÂ parameter,Â selfÂ helps you distinguish between the property and the parameter â€“Â self.nameÂ refers to the property, whereasÂ nameÂ refers to the parameter.

But what if we didnâ€™t always need the family tree for a particular person? If we add theÂ lazyÂ keyword to theÂ familyTreeÂ property, then Swift will only create theÂ FamilyTreeÂ struct when itâ€™s first accessed:

So, if you want to see the â€œCreating family tree!â€ message, you need to access the property at least once:

All the properties and methods weâ€™ve created so far have belonged to individual instances of structs, which means that if we had aÂ StudentÂ struct we could create several student instances each with their own properties and methods:

You can also ask Swift to share specific properties and methods across all instances of the struct by declaring them asÂ static.
To try this out, weâ€™re going to add a static property to theÂ StudentÂ struct to store how many students are in the class. Each time we create a new student, weâ€™ll add one to it:
Because theÂ classSizeÂ struct belongs to the struct itself rather than instances of the struct, we need to read it usingÂ Student.classSize:

Access control lets you restrict which code can use properties and methods. This is important because you might want to stop people reading a property directly, for example.
We could create aÂ PersonÂ struct that has anÂ idÂ property to store their social security number:
Once that person has been created, we can make theirÂ idÂ be private so you canâ€™t read it from outside the struct â€“Â trying to writeÂ ed.idÂ simply wonâ€™t work.
Just use theÂ privateÂ keyword, like this:
Now only methods insideÂ PersonÂ can read theÂ idÂ property. For example:
Another common option isÂ public, which lets all other code use the property or method.

Youâ€™ve made it to the end of the seventh part of this series, so letâ€™s summarize:
1. You can create your own types using structures, which can have their own properties and methods.
2. You can use stored properties or use computed properties to calculate values on the fly.
3. If you want to change a property inside a method, you must mark it asÂ mutating.
4. Initializers are special methods that create structs. You get a memberwise initializer by default, but if you create your own you must give all properties a value.
5. Use theÂ selfÂ constant to refer to the current instance of a struct inside a method.
6. TheÂ lazyÂ keyword tells Swift to create properties only when they are first used.
7. You can share properties and methods across all instances of a struct using theÂ staticÂ keyword.
8. Access control lets you restrict what code can use properties and methods.

Recall private vs public  keyword

2 /6

day8__Tu/6/11__Day#8: STRUCT, PROP 
	âœ…	session1__10AM
		session2__330PM

Anyway, todayâ€™s topic isÂ structs. Structs let us create our own data types out of several small types. For example, you might put three strings and a boolean together and say that represents a user in your app.

These custom types â€“Â users, games, documents, and more â€“Â form the real core of the software we build. If you getÂ thoseÂ right then often your code will follow.
As Fred Brooks, the author of the hugely influential bookÂ The Mythical Man-Month, once said, â€œthe programmer at witâ€™s end... can often do best by disentangling themself from their code, rearing back, and contemplating their data. Representation is the essence of programming.â€

Swift lets you design your own types in two ways, of which the most common are called structures, or justÂ structs. Structs can be given their own variables and constants, and their own functions, then created and used however you want.

Letâ€™s start with a simple example: weâ€™re going to create aÂ SportÂ struct that stores its name as a string. Variables inside structs are calledÂ properties, so this is a struct with one property:

That defines the type, so now we can create and use an instance of it:

Properties can have default values just like regular variables, and you can usually rely on Swiftâ€™s type inference.

That has aÂ nameÂ property that stores aÂ String. These are calledÂ storedÂ properties, because Swift has a different kind of property called aÂ computedÂ property â€“Â a property that runs code to figure out its value.
Weâ€™re going to add another stored property to theÂ SportÂ struct, then a computed property. Hereâ€™s how that looks:

As you can see,Â olympicStatusÂ looks like a regularÂ String, but it returns different values depending on the other properties.
We can try it out by creating a new instance ofÂ Sport:

Property observers let you run code before or after any property changes. To demonstrate this, weâ€™ll write aÂ ProgressÂ struct that tracks a task and a completion percentage:

We can now create an instance of that struct and adjust its progress over time:
What weÂ wantÂ to happen is for Swift to print a message every timeÂ amountÂ changes, and we can use aÂ didSetÂ property observer for that. This will run some code every timeÂ amountÂ changes:

You can also useÂ willSetÂ to take actionÂ beforeÂ a property changes, but that is rarely used.

Structs can have functions inside them, and those functions can use the properties of the struct as they need to. Functions inside structs are calledÂ methods, but they still use the sameÂ funcÂ keyword.

We can demonstrate this with aÂ CityÂ struct. This will have aÂ populationÂ property that stores how many people are in the city, plus aÂ collectTaxes()Â method that returns the population count multiplied by 1000. Because the method belongs toÂ CityÂ it can read the current cityâ€™sÂ populationÂ property.

That method belongs to the struct, so we call it on instances of the struct like this:

If a struct has a variable property but the instance of the struct was created as a constant, that property canâ€™t be changed â€“Â the struct is constant, so all its properties are also constant regardless of how they were created.

The problem is that when you create the struct Swift has no idea whether you will use it with constants or variables, so by default it takes the safe approach: Swift wonâ€™t let you write methods that change properties unless you specifically request it.

When youÂ wantÂ to change a property inside a method, you need to mark it using theÂ mutatingÂ keyword, like this:

Because it changes the property, Swift will only allow that method to be called onÂ PersonÂ instances that are variables:

Weâ€™ve used lots of strings so far, and it turns out they are structs â€“Â they have their own methods and properties we can use to query and manipulate the string.

First, letâ€™s create a test string:
You can read the number of characters in a string using itsÂ countÂ property:
They have aÂ hasPrefix()Â method that returns true if the string starts with specific letters:
You can uppercase a string by calling itsÂ uppercased()Â method:
And you can even have Swift sort the letters of the string into an array:

Arrays are also structs, which means they too have their own methods and properties we can use to query and manipulate the array.

You can read the number of items in an array using itsÂ countÂ property:
If you want to add a new item, use theÂ append()Â method like this:
You can locate any item inside an array using itsÂ firstIndex()Â method, like this:
That will return 1 because arrays count from 0.
Just like with strings, you can have Swift sort the items of the array alphabetically:
Finally, if you want to remove an item, use theÂ remove()Â method like this:



Recall the SPECIAL KEYWORD 	didSet {
Recall 	didSet vs. willSet

Recall: nothing happens until you actually call the function



day7__M/6/10__Day#7: CLOSURES II
	âœ…session1__2:13PM
	âœ…session2__6pm (45min) ==> on lesson 12

Yesterday you learned the basics of closures, but today things get a little trickier. But thatâ€™s OK: Benjamin Franklin once said, â€œenergy and persistence conquer all thingsâ€ â€“ you can do this!
Sometimes closure syntax can be a bit hard on your eyes. If you find it a bit overwhelming â€“Â if youâ€™re staring at some code and arenâ€™t 100% sure of what it means â€“ just go back one video and watch it again.

This is where closures can start to be read a bit like line noise: a closure you pass into a function can also accept its own parameters.
Weâ€™ve been usingÂ () -> VoidÂ to mean â€œaccepts no parameters and returns nothingâ€, but you can go ahead and fill theÂ ()Â with the types of any parameters that your closure should accept.
To demonstrate this, we can write aÂ travel()Â function that accepts a closure as its only parameter, and that closure in turn accepts a string:

Weâ€™ve been usingÂ () -> VoidÂ to mean â€œaccepts no parameters and returns nothingâ€, but you can replace thatÂ VoidÂ with any type of data to force the closure to return a value.
To demonstrate this, we can write aÂ travel()Â function that accepts a closure as its only parameter, and that closure in turn accepts a string and returns a string:

Swift has a shorthand syntax that lets you go even shorter. Rather than writingÂ place inÂ we can let Swift provide automatic names for the closureâ€™s parameters. These are named with a dollar sign, then a number counting from 0.

Just to make sure everything is clear, weâ€™re going to write another closure example using two parameters.
This time ourÂ travel()Â function will require a closure that specifies where someone is traveling to, and the speed they are going. This means we need to useÂ (String, Int) -> StringÂ for the parameterâ€™s type:

Weâ€™re going to call that using a trailing closure and shorthand closure parameter names. Because this accepts two parameters, weâ€™ll be getting bothÂ $0Â andÂ $1:

Some people prefer not to use shorthand parameter names likeÂ $0Â because it can be confusing, and thatâ€™s OK â€“ do whatever works best for you.

In the same way that you can pass a closureÂ toÂ a function, you can get closures returnedÂ fromÂ a function too.
The syntax for this is a bit confusing a first, because it usesÂ ->Â twice: once to specify your functionâ€™s return value, and a second time to specify your closureâ€™s return value.
To try this out, weâ€™re going to write aÂ travel()Â function that accepts no parameters, but returns a closure. The closure that gets returned must be called with a string, and will return nothing.

We can now callÂ travel()Â to get back that closure, then call it as a function:
Itâ€™s technically allowable â€“Â although really not recommended! â€“Â to call the return value fromÂ travel()directly:

If you use any external values inside your closure, SwiftÂ capturesÂ them â€“Â stores them alongside the closure, so they can be modified even if they donâ€™t exist any more.
Right now we have aÂ travel()Â function that returns a closure, and the returned closure accepts a string as its only parameter and returns nothing:
We can callÂ travel()Â to get back the closure, then call that closure freely:
Closure capturing happens if we create values inÂ travel()Â that get used inside the closure. For example, we might want to track how often the returned closure is called:
Even though thatÂ counterÂ variable was created insideÂ travel(), it gets captured by the closure so it will still remain alive for that closure.
So, if we callÂ result("London")Â multiple times, the counter will go up and up:




<Â Previous: Capturing values		Table of ContentsÂ >
Closures summary

An error occurred.
Try watching this video on www.youtube.com, or enable JavaScript if it is disabled in your browser.
Youâ€™ve made it to the end of the sixth part of this series, so letâ€™s summarize:
1. You can assign closures to variables, then call them later on.
2. Closures can accept parameters and return values, like regular functions.
3. You can pass closures into functions as parameters, and those closures can have parameters of their own and a return value.
4. If the last parameter to your function is a closure, you can use trailing closure syntax.
5. Swift automatically provides shorthand parameter names likeÂ $0Â andÂ $1, but not everyone uses them.
6. If you use external values inside your closures, they will be captured so the closure can refer to them later.


Eldonde cliffs
Remember, stay accountable: tell the world that youâ€™ve just learned all about closures in Swift, and discuss them with others who are learning too.



day6__Sun/6/9__Day#6: CLOSURES I
	session1__8am
	session2__120PM


Brace yourself, because today weâ€™re covering the first thing in Swift that many people have hard time understanding. Please keep in mind Flip Wilson's law: â€œyou can't expect to hit the jackpot if you don't put a few nickels in the machine.â€

Sometimes people ask me â€œwhy do you start some topics by saying they are hard â€“ arenâ€™t you just putting people off?â€
Obviously my goal isÂ notÂ to put you off Swift. Instead, my hope is that when you struggle with something you donâ€™t ever think to yourself â€œIâ€™m not cut out for Swift.â€ If you find closures hard itâ€™sÂ notÂ because you arenâ€™t smart enough â€“Â theyÂ areÂ hard, so itâ€™s just a sign your brain is working properly.
Donâ€™t despair. Sometimes fighting to learn something makes it stick in your head better â€“Â there is no learning without struggle!
You can do this.

Swift lets us use functions just like any other type such as strings and integers. This means you can create a function and assign it to a variable, call that function using that variable, and even pass that function into other functions as parameters.
Functions used in this way are calledÂ closures, and although they work like functions they are written a little differently

When you create closures, they donâ€™t have a name or space to write any parameters. That doesnâ€™t mean they canâ€™tÂ acceptÂ parameters, just that they do so in a different way: they are listedÂ insideÂ the open braces.

To make a closure accept parameters, list them inside parentheses just after the opening brace, then writeÂ inÂ so that Swift knows the main body of the closure is starting.

One of the differences between functions and closures is that you donâ€™t use parameter labels when running closures

Closures can also return values, and they are written similarly to parameters: you write them inside your closure, directly before theÂ inÂ keyword.

We want a closure that returns a string rather than printing the message directly, so we need to useÂ -> StringÂ beforeÂ in, then useÂ returnÂ just like a normal function:

Because closures can be used just like strings and integers, you can pass them into functions. The syntax for this can hurt your brain at first, so weâ€™re going to take it slow.

If we wanted to pass that closure into a function so it can be run inside that function, we would specify the parameter type asÂ () -> Void. That means â€œaccepts no parameters, and returnsÂ Voidâ€ â€“Â Swiftâ€™s way of saying â€œnothingâ€.

If the last parameter to a function is a closure, Swift lets you use special syntax calledÂ trailing closure syntax. Rather than pass in your closure as a parameter, you pass it directly after the function inside braces.

In fact, because there arenâ€™t any other parameters, we can eliminate the parentheses entirely:

This is where closures can start to be read a bit like line noise: a closure you pass into a function can also accept its own parameters.
Weâ€™ve been usingÂ () -> VoidÂ to mean â€œaccepts no parameters and returns nothingâ€, but you can go ahead and fill theÂ ()Â with the types of any parameters that your closure should accept.
To demonstrate this, we can write aÂ travel()Â function that accepts a closure as its only parameter, and that closure in turn accepts a string:


Weâ€™ve been usingÂ () -> VoidÂ to mean â€œaccepts no parameters and returns nothingâ€, but you can replace thatÂ VoidÂ with any type of data to force the closure to return a value.
To demonstrate this, we can write aÂ travel()Â function that accepts a closure as its only parameter, and that closure in turn accepts a string and returns a string:

Swift has a shorthand syntax that lets you go even shorter. Rather than writingÂ place inÂ we can let Swift provide automatic names for the closureâ€™s parameters. These are named with a dollar sign, then a number counting from 0.
â€¦


day5__Sat/6/8__Day#5: FUNCTIONS ET AL 
	640am start
	session2_11am
		(6/11) tests == 54%

Functions let us wrap up pieces of code so they can be used in lots of places. We can send data into functions to customize how they work, and get back data that tells us the result that was calculated.
Believe it or not, function calls used to be really slow. Steve Johnson, the author of many early coding tools for the Unix operating system, said this:
â€œDennis Ritchie (the creator of the C programming language) encouraged modularity by telling all and sundry that function calls were really, really cheap in C. Everybody started writing small functions and modularizing. Years later we found out that function calls were still expensive, and our code was often spending 50% of its time just calling them. Dennis had lied to us! But it was too late; we were all hooked...â€

Think, running a function == calling a function 

Functions let us re-use code, which means we can write a function to do something interesting then run that function from lots of places. Repeating code is generally a bad idea, and functions help us avoid doing that.
To start with, weâ€™re going to write a function that prints help information for users of our app. We might need this anywhere in our app, so having it as a function is a good idea.
Swift functions start with theÂ funcÂ keyword, then your function name, then open and close parentheses. All the body of your function â€“ the code that should be run when the function is requested â€“ is placed inside braces.

Running a function is often referred to asÂ callingÂ a function.

Functions become more powerful when they can be customized each time you run them. Swift lets you send values to a function that can then be used inside the function to change the way it behaves. Weâ€™ve used this already â€“Â weâ€™ve been sending strings and integers to theÂ print()Â function

Values sent into functions this way are calledÂ parameters.
To make your own functions accept parameters, give each parameter a name, then a colon, then tell Swift the type of data it must be. All this goes inside the parentheses after your function name.
For example, we can write a function to print the square of any number:

That tells Swift we expect to receive anÂ Int, and it should be calledÂ number. This name is used both inside the function when you want to refer to the parameter, but also when you run the function

As well as receiving data, functions can also send back data. To do this, write a dash then a right angle bracket ( -> ) after your functionâ€™s parameter list, then tell Swift what kind of data will be returned.

Inside your function, you use theÂ returnÂ keyword to send a value back if you have one. Your function then immediately exits, sending back that value â€“Â no other code from that function will be run.

Swift lets us provide two names for each parameter: one to be used externally when calling the function, and one to be used internally inside the function. This is as simple as writing two names, separated by a space.

The parameter is calledÂ to name, which means externally itâ€™s calledÂ to, but internally itâ€™s calledÂ name. This gives variables a sensible name inside the function, but means calling the function reads naturally:

You might have noticed that we donâ€™t actually send any parameter names when we callÂ print()Â â€“ we sayÂ print("Hello")Â rather thanÂ print(message: "Hello").
You can get this same behavior in your own functions by using an underscore,Â _, for your external parameter name,Â 


You can now callÂ greet()Â without having to use theÂ personÂ parameter name:
This can make some code more natural to read, but generally itâ€™s better to give your parameters external names to avoid confusion.

TheÂ print()Â function prints something to the screen, but always adds a new line to the end of whatever you printed, so that multiple calls toÂ print()Â donâ€™t all appear on the same line.
You can change that behavior if you want, so you could use spaces rather than line breaks. Most of the time, though, folks want new lines, soÂ print()Â has aÂ terminatorÂ parameter that uses new line as its default value.
You can give your own parameters a default value just by writing anÂ =Â after its type followed by the default you want to give it. So, we could write aÂ greet()Â function that can optionally print nice greetings
That can be called in two ways:

Some functions areÂ variadic, which is a fancy way of saying they accept any number of parameters of the same type. TheÂ print()Â function is actually variadic: if you pass lots of parameters, they are all printed on one line with spaces between them:

You can make any parameter variadic by writingÂ ...Â after its type. So, anÂ IntÂ parameter is a single integer, whereasÂ Int...Â is zero or more integers â€“ potentially hundreds.
Inside the function, Swift converts the values that were passed in to an array of integers, so you can loop over them as needed.
To try this out, letâ€™s write aÂ square()Â function that can square many numbers:

Sometimes functions fail because they have bad input, or because something went wrong internally. Swift lets us throw errors from functions by marking them asÂ throwsÂ before their return type, then using theÂ throwÂ keyword when something goes wrong.

Swift doesnâ€™t like errors to happen when your program runs, which means it wonâ€™t let you run an error-throwing function by accident.
Instead, you need to call these functions using three new keywords:Â doÂ starts a section of code that might cause problems,Â tryÂ is used before every function that might throw an error, andÂ catchÂ lets you handle errors gracefully.

If any errors are thrown inside theÂ doÂ block, execution immediately jumps to theÂ catchÂ block. Letâ€™s try callingÂ checkPassword()Â with a parameter that throws an error:

When that code runs, â€œYou canâ€™t use that passwordâ€ is printed, but â€œThat password is goodâ€ wonâ€™t be â€“Â that code will never be reached, because the error is thrown.

Youâ€™ve made it to the end of the fifth part of this series, so letâ€™s summarize:
1. Functions let us re-use code without repeating ourselves.
2. Functions can accept parameters â€“Â just tell Swift the type of each parameter.
3. Functions can return values, and again you just specify what type will be sent back. Use tuples if you want to return several things.
4. You can use different names for parameters externally and internally, or omit the external name entirely.
5. Parameters can have default values, which helps you write less code when specific values are common.
6. Variadic functions accept zero or more of a specific parameter, and Swift converts the input to an array.
7. Functions can throw errors, but you must call them usingÂ tryÂ and handle errors usingÂ catch.
8. You can useÂ inoutÂ to change variables inside a function, but itâ€™s usually better to return a new value.




day4__F/6/7__Day#4: LOOPS
	session2_5pm

	===remember to complete the tests

Swift has a few ways of writing loops, but their underlying mechanism is the same: run some code repeatedly until a condition evaluates as false.
The most common loop in Swift is aÂ forÂ loop: it will loop over arrays and ranges, and each time the loop goes around it will pull out one item and assign to a constant.

We can use aÂ forÂ loop to print each item.

If you donâ€™t use the constant thatÂ forÂ loops give you, you should use an underscore instead so that Swift doesnâ€™t create needless value.

Remember: donâ€™t get tripped up on the forward vs backslash bullshit

Recall: itâ€™s, \ , FORWARD SLASH, OPEN PARENTHESISâ€¦
\ ( ) 

	â€”>onto WHILE LOOPS

A second way of writing loops is usingÂ while: give it a condition to check, and its loop code will go around and around until the condition fails.
For example, we could use aÂ whileÂ loop to simulate a child counting in a game of hide and seek: we start at one, count up to and including 20 while printing each number out, then after the loop print â€œReady or notâ€.

The third way of writing loops is not commonly used, but itâ€™s so simple to learn we might as well cover it: itâ€™s called theÂ repeatÂ loop, and itâ€™s identical to aÂ whileÂ loop except the condition to check comes at the end.

Because the condition comes at theÂ endÂ of theÂ repeatÂ loop the code inside the loop will always be executed at least once, whereasÂ whileÂ loops check their condition before their first run.

You can exit a loop at any time using theÂ breakÂ keyword.

With that change, as soon asÂ countDownÂ reaches 4 the astronautâ€™s message will be printed, and the rest of the loop gets skipped.

If you put a loop inside a loop itâ€™s called aÂ nestedÂ loop, and itâ€™s not uncommon to want to break out of both the inner loop and the outer loop at the same time.

As youâ€™ve seen, theÂ breakÂ keyword exits a loop. But if you just want to skip the current item and continue on to the next one, you should useÂ continueÂ instead.

To try this out, we can write a loop from 1 through 10, then use Swiftâ€™s remainder operator to skip any numbers that are odd:

Remember, the remainder operator figures out how many times 2 fits into each number in our loop, then returns whatever is left over. So, if 1 is left over, it means the number is odd, so we can useÂ continueÂ to skip it.

Itâ€™s common to useÂ whileÂ loops to makeÂ infiniteÂ loops:Â loops that either have no end or only end when youâ€™re ready. All apps on your iPhone use infinite loops, because they start running, then continually watch for events until you choose to quit them.

To make an infinite loop, just useÂ trueÂ as your condition.Â trueÂ is always true, so the loop will repeat forever.Â Warning:Â Please make sure you have a check that exits your loop, otherwise it will never end.

Youâ€™ve made it to the end of the fourth part of this series, so letâ€™s summarize:
1. Loops let us repeat code until a condition is false.
2. The most common loop isÂ for, which assigns each item inside the loop to a temporary constant.
3. If you donâ€™t need the temporary constant thatÂ forÂ loops give you, use an underscore instead so Swift can skip that work.
4. There areÂ whileÂ loops, which you provide with an explicit condition to check.
5. Although they are similar toÂ whileÂ loops,Â repeatÂ loops always run the body of their loop at least once.
6. You can exit a single loop usingÂ break, but if you have nested loops you need to useÂ break followed by whatever label you placed before your outer loop.
7. You can skip items in a loop usingÂ continue.
8. Infinite loops donâ€™t end until you ask them to, and are made usingÂ while true. Make sure you have a condition somewhere to end your infinite loops!


/=/=/=


Loops are one of the things that make computers so utterly brilliant: the ability to repeat some simple task billions of times every second.
Of course, whatÂ goesÂ in those loops is down to you: you might be adding some numbers, you might be reading some sensor data, or you might be redrawing the screen 120 times a second. As Craig Bruce said, â€œitâ€™s hardware that makes a machine fast, but itâ€™s software that makes a fast machine slow.â€



day4__F/6/7__Day#3: OPERATORS & CONDITIONS

Swift has several operators that perform comparison, and these work more or less like you would expect in mathematics.

There are two operators that check for equality:Â ==Â checks two values are the same, andÂ !=(pronounced â€œnot equalsâ€) checks two values areÂ notÂ the same.

here are four operators for comparing whether one value is greater than, less than, or equal to another.Â 

Each of these also work with strings, because strings have a natural alphabetical order

Now you know some operators you can write conditions usingÂ ifÂ statements. You give Swift a condition, and if that condition is true it will run code of your choosing.
To try this out, I want to use a Swift function calledÂ print(): you run it with some text, and it will be printed out.

The code inside the braces â€“Â {Â andÂ }Â â€“Â will be printed if the condition is true. If you want you can provide alternative code to run if the condition isÂ false, usingÂ else.

You can also chain conditions together usingÂ else if.

Swift has two special operators that let us combine conditions together: they areÂ &&Â (pronounced â€œandâ€) andÂ ||Â (pronounced â€œorâ€).

ThatÂ print()Â call will only happen if both ages are over 18, which they arenâ€™t. In fact, Swift wonâ€™t even bother checking the value ofÂ age2Â because it can see thatÂ age1Â already failed the test.
The alternative toÂ &&Â isÂ ||, which evaluates as true if either item passes the test.Â 

You can useÂ &&Â andÂ ||Â more than once in a single condition, but donâ€™t make things too complicated otherwise it can be hard to read!

Swift has a rarely used operator called the ternary operator. It works with three values at once, which is where its name comes from: it checks a condition specified in the first value, and if itâ€™s true returns the second value, but if its false returns the third value.
The ternary operator is a condition plus true or false blocks all in one, split up by a question mark and a colon, all of which which makes it rather hard to read.Â 

That checks whether the two cards are the same, then prints â€œCards are the sameâ€ if the condition is true, or â€œCards are differentâ€ if itâ€™s false.

If you have several conditions usingÂ ifÂ andÂ else if, itâ€™s often clearer to use a different construct known asÂ switch case. Using this approach you write your condition once, then list all possible outcomes and what should happen for each of them.


The last case â€“Â defaultÂ â€“Â is required because Swift makes sure you cover all possible cases so that no eventuality is missed off. If the weather is anything other than rain, snow, or sun, theÂ defaultÂ case will be run.

Swift will only run the code inside each case. If you want execution to continue on to the next case, use theÂ fallthroughÂ keyword like this:

Swift gives us two ways of making ranges: theÂ ..<Â andÂ ...Â operators. The half-open range operator,Â ..<, creates ranges up to but excluding the final value, and the closed range operator,Â ..., creates ranges up to andÂ includingÂ the final value.
For example, the rangeÂ 1..<5Â contains the numbers 1, 2, 3, and 4, whereas the rangeÂ 1...5Â contains the numbers 1, 2, 3, 4, and 5.

As before, theÂ defaultÂ case must be there to ensure all possible values are covered.

Recall that SWITCH must be exhaustive

Youâ€™ve made it to the end of the third part of this series, so letâ€™s summarize:
1. Swift has operators for doing arithmetic and for comparison; they mostly work like you already know.
2. There are compound variants of arithmetic operators that modify their variables in place:Â +=,Â -=, and so on.
3. You can useÂ if,Â else, andÂ else ifÂ to run code based on the result of a condition.
4. Swift has a ternary operator that combines a check with true and false code blocks. Although you might see it in other code, I wouldnâ€™t recommend using it yourself.
5. If you have multiple conditions using the same value, itâ€™s often clearer to useÂ switchÂ instead.
6. You can make ranges usingÂ ..<Â andÂ ...Â depending on whether the last number should be excluded or included.
âœ…


day3__Th/6/6/__Day#3: OPERATORS & CONDITIONS
1:40PM start XXX
3:30PM start XXX
10:30PM start
Passed out during module 4â€¦woke up 1:30am


Now you know all the basic types in Swift, we can start to put them together using operators. Operators are those little matematical symbols likeÂ +Â andÂ -
Swift supports operator overloading, which is a fancy way of saying that what an operator does depends on the values you use it with.

Remember, Swift is a type-safe language, which means it wonâ€™t let you mix types. For example, you canâ€™t add an integer to a string because it doesnâ€™t make any sense.

Swift has shorthand operators that combine one operator with an assignment, so you can change a variable in place. These look like the existing operators you know â€“Â +,Â -,Â *, andÂ /, but they have anÂ =on the end because they assign the result back to whatever variable you were using.



/-/-

Sometimes you need to be able to assign values to enums so they have meaning. This lets you create them dynamically, and also use them in different ways.
Swift will automatically assign each of those a number starting from 0, and you can use that number to create an instance of the appropriate enum case.
If you want, you can assign one or more cases a specific value, and Swift will generate the rest. Itâ€™s

Youâ€™ve made it to the end of the second part of this series, so letâ€™s summarize:
1. Arrays, sets, tuples, and dictionaries let you store a group of items under a single value. They each do this in different ways, so which you use depends on the behavior you want.
2. Arrays store items in the order you add them, and you access them using numerical positions.
3. Sets store items without any order, so you canâ€™t access them using numerical positions.
4. Tuples are fixed in size, and you can attach names to each of their items. You can read items using numerical positions or using your names.
5. Dictionaries store items according to a key, and you can read items using those keys.
6. Enums are a way of grouping related values so you can use them without spelling mistakes.
7. You can attach raw values to enums so they can be created from integers or strings, or you can add associated values to store additional information about each case.




day2__W/6/5__Day#2: ARRAYS et all
Start 3:20

Arrays are collections of values that are stored as a single value. For example, John, Paul, George, and Ringo are names, but arrays let you group them in a single value called The Beatles.

That last line makes the array: it starts and ends with brackets, with each item in the array separated by a comma.
You can read values from an array by writing a number inside brackets. Array positions count from 0, so if you want to read â€œPaul McCartneyâ€ you would write this:

Be careful: Swift crashes if you read an item that doesnâ€™t exist.

Note:Â If youâ€™re using type annotations, arrays are written in brackets:Â [String],Â [Int],Â [Double], andÂ [Bool].


Sets are collections of values just like arrays, except they have two differences:
1. Items arenâ€™t stored in any order; they are stored in what is effectively a random order.
2. No item can appear twice in a set; all items must be unique.

When you look at the value ofÂ colorsÂ inside the playground output youâ€™ll see it doesnâ€™t match the order we used to create it. Itâ€™s not really aÂ randomÂ order, itâ€™s justÂ unorderedÂ â€“ Swift makes no guarantees about its order. 
	bc they are unordered, you canâ€™t read values from a set using numerical positions 
	like you can with arrays.
	If you try to insert a duplicate item into a set, the duplicates get ignored.

Tuples allow you to store several values together in a single value. That might sound like arrays, but tuples are different:
1. You canâ€™t add or remove items from a tuple; they are fixed in size.
2. You canâ€™t change the type of items in a tuple; they always have the same types they were created with.
3. You can access items in a tuple using numerical positions or by naming them, but Swift wonâ€™t let you read numbers or names that donâ€™t exist.

Tuples are created by placing multiple items into parentheses,Â 

You then access items using numerical positions starting from 0
Or you can access items using their names

Remember, you can change the values inside a tuple after you create it, BUT NOT theÂ typesÂ of values. So, if you tried to changeÂ nameÂ to beÂ (first: "Justin", age: 25)Â you would get an error.

Arrays, sets, and tuples can seem similar at first, but they have distinct uses. To help you know which to use, here are some rules.
	If you need a specific, FIXED collection of related values where each item has a 	precise position or name, you should use a tuple

	If you need a collection of values that must be UNIQUE or you need to be able to 	check whether a specific item is in there extremely quickly, you should use a set

	If you need a collection of values that can contain duplicates, or the ORDER of 	your items MATTERS, you should use an array


Dictionaries are collections of values just like arrays, but rather than storing things with an integer position you can access them using anything you want.
The most common way of storing dictionary data is using strings. For example, we could create a dictionary that stores the height of singers using their name

Just like arrays, dictionaries start and end with brackets and each item is separated with a comma. However, we also use a colon to separate the value you want to store (e.g. 1.78) from the identifier you want to store it under (e.g. â€œTaylor Swiftâ€).

These identifiers are calledÂ keys, and you can use them to read data back out of the dictionary

When using type annotations, dictionaries are written in brackets with a colon between your identifier and value types. For example,Â [String: Double]Â andÂ [String: String].

If you try to read a value from a dictionary using a key that doesnâ€™t exist, Swift will send you backÂ nilÂ â€“Â nothing at all. While this might be what you want, thereâ€™s an alternative: we can provide the dictionary with a default value to use if we request a missing key.

But if we tried reading the favorite ice cream for Charlotte, weâ€™d get back nil, meaning that Swift doesnâ€™t have a value for that key
We can fix this by giving the dictionary a default value of â€œUnknownâ€, so that when no ice cream is found for Charlotte we get back â€œUnknownâ€ rather than nil

Arrays, sets, and dictionaries are calledÂ collections, because they collect values together in one place.
If you want to create anÂ emptyÂ collection just write its type followed by opening and closing parentheses.Â 

The exception is creating an empty set, which is done differentl
This is because Swift has special syntax only for dictionaries and arrays; other types must use angle bracket syntax like sets.


Enumerations â€“ usually called justÂ enumsÂ â€“ are a WAY OF DEFINING groups of related values in a way that makes them easier to use.
For example, if you wanted to write some code to represent the success or failure of some work you were doing, you could represent that as strings

But what happens if someone accidentally uses different naming?


All those three are different strings, so they mean different things.
With enums we can define aÂ ResultÂ type that can be eitherÂ successÂ orÂ failure, like this:

And now when we use it we must choose one of those two values:
This stops you from accidentally using different strings each time.

As well as storing a simple value, enums can also STORE ASSOCIATED VALUES attached to each case. This lets you attach additional information to your enums so they can represent more nuanced data.

That lets us say that someone is talking, but we donâ€™t know what they talkingÂ about, or we can know that someone is running, but we donâ€™t know where they are runningÂ to.
Enum associated values let us add those additional details


Now we can be more precise â€“ we can say that someone is talking about football:

Sometimes you need to be able to assign values to enums so they have meaning. This lets you create them dynamically, and also use them in different ways.

==============================

==============================

day1__Tu/6/4__Day#1: VAR et al

variables, which are places where you can store program data.
	called variables because they canÂ varyÂ â€“Â you can change their values freely.

BecauseÂ strÂ is a variable we can change it:
We donâ€™t needÂ varÂ the second time because the variable has already been created â€“ weâ€™re just changing it.

Swift is whatâ€™s known as a type-safe language, which means that every variable must be of one specific type. TheÂ strÂ variable that Xcode created for us holds a string of letters that spell â€œHello, playgroundâ€, so Swift assigns it the typeÂ String

Variables can hold a whole number, so Swift assigns the TYPEÂ IntÂ â€“Â short for â€œintegerâ€.
	If you have large numbers, Swift lets you use underscores as thousands separators â€“Â they donâ€™t change the number, but they do make it easier to read
Strings and integers are different types, and they canâ€™t be mixed. So, while itâ€™s safe to changeÂ strÂ to â€œGoodbyeâ€, I canâ€™t make it 38 because thatâ€™s anÂ IntÂ not aÂ String.


Standard Swift strings use double quotes, but you canâ€™t include line breaks in there.
	If you want multi-line strings you need slightly different syntax: 
	start and end with three double quote marks """

	Swift is very particular about how you write those quote marks: the opening and 	closing triple must be on their own line, but that opening and closing line breaks 	wonâ€™t be included in your final string.

If you only want multi-line strings to format your code neatly, and you donâ€™t want those line breaks to actually be in your string, end each line with aÂ \, like this:

***escaped new line on the final line is not allowed

Two other basic types of data in Swift are doubles and booleans

	â€œDoubleâ€ is short for â€œdouble-precision floating-point numberâ€, fancy way of 
	saying it holds fractional values such as 38.1, or 3.141592654.

Whenever you create a variable with a fractional number, Swift automatically gives that variable the typeÂ Double

Doubles are different from integers, and you canâ€™t mix them.

booleans are much simpler: they just hold either true or false; 
	Swift will automatically assign the boolean type to any variable assigned either true or false as its value


Swift also has a feature called STRING INTERPOLATION â€“ the ability to place variables inside your strings to make them more useful.

You can place any type of variable inside your string â€“Â all you have to do is write a backslash,Â \, followed by your variable name in parentheses.Â 
As youâ€™ll see later on, string interpolation isnâ€™t just limited to placing variables â€“Â you can actually run code inside there.

variables have that name bc their values can change over time, and that is often useful. However, very often you want to set a value once and never change it, and so we have an alternative to theÂ varÂ keyword calledÂ let.

letÂ keyword createsÂ constants, which are values that can be set once and never again

Swift assigns each variable and constant a type based on what value itâ€™s given when itâ€™s created. Ie:
	let str = â€œhello world!â€

That will makeÂ strÂ a string, so you canâ€™t try to assign it an integer or a boolean later on. This is calledÂ type inference: Swift is able to infer the type of something based on how you created it.

If you want you can be explicit about the type of your data rather than relying on Swiftâ€™s type inference,Â 

Notice that booleans have the short type nameÂ Bool, in the same way that integers have the short type nameÂ Int.

	***Use constants as often as possible***

Youâ€™ve made it to the end of the first part of this series, so letâ€™s summarize.
1. You make variables usingÂ varÂ and constants usingÂ let. Itâ€™s preferable to use constants as often as possible.
2. Strings start and end with double quotes, but if you want them to run across multiple lines you should use three sets of double quotes.
3. Integers hold whole numbers, doubles hold fractional numbers, and booleans hold true or false.
4. String interpolation allows you to create strings from other variables and constants, placing their values inside your string.
5. Swift uses type inference to assign each variable or constant a type, but you can provide explicit types if you want.


==> part2:
	https://www.raywenderlich.com/ios/learn
